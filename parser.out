Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLINK
    BOOKED
    COMMA
    CONST
    DELETE
    DIVENT
    DIVIDE
    DOT
    ELSE
    EXP
    F
    FOR
    GLOBAL
    GT
    GTE
    IF
    INSERT
    LCORCH
    LEN
    LENGHTERROR
    LT
    LTE
    MINUS
    MOD
    NE
    NEG
    PARENTCL
    PARENTCR
    PLUS
    PROCEDURE
    RANGE
    RCORCH
    T
    TIMES
    TP
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     statement -> simpleAssignment function
Rule 3     simpleAssignment -> ID ASSIGN term SEMICOLON statement
Rule 4     simpleAssignment -> empty
Rule 5     function -> type statement
Rule 6     function -> empty
Rule 7     type -> TYPE LPARENT ID RPARENT SEMICOLON
Rule 8     term -> FALSE
Rule 9     term -> TRUE
Rule 10    term -> factor
Rule 11    factor -> ID
Rule 12    factor -> INT
Rule 13    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 3
BLINK                : 
BOOKED               : 
COMMA                : 
CONST                : 
DELETE               : 
DIVENT               : 
DIVIDE               : 
DOT                  : 
ELSE                 : 
EXP                  : 
F                    : 
FALSE                : 8
FOR                  : 
GLOBAL               : 
GT                   : 
GTE                  : 
ID                   : 3 7 11
IF                   : 
INSERT               : 
INT                  : 12
LCORCH               : 
LEN                  : 
LENGHTERROR          : 
LPARENT              : 7
LT                   : 
LTE                  : 
MINUS                : 
MOD                  : 
NE                   : 
NEG                  : 
PARENTCL             : 
PARENTCR             : 
PLUS                 : 
PROCEDURE            : 
RANGE                : 
RCORCH               : 
RPARENT              : 7
SEMICOLON            : 3 7
T                    : 
TIMES                : 
TP                   : 
TRUE                 : 9
TYPE                 : 7
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

empty                : 4 6
factor               : 10
function             : 2
program              : 0
simpleAssignment     : 2
statement            : 1 3 5
term                 : 3
type                 : 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) statement -> . simpleAssignment function
    (3) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (4) simpleAssignment -> . empty
    (13) empty -> .

    ID              shift and go to state 4
    TYPE            reduce using rule 13 (empty -> .)
    $end            reduce using rule 13 (empty -> .)

    program                        shift and go to state 1
    statement                      shift and go to state 2
    simpleAssignment               shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) statement -> simpleAssignment . function
    (5) function -> . type statement
    (6) function -> . empty
    (7) type -> . TYPE LPARENT ID RPARENT SEMICOLON
    (13) empty -> .

  ! shift/reduce conflict for TYPE resolved as shift
    TYPE            shift and go to state 9
    $end            reduce using rule 13 (empty -> .)

  ! TYPE            [ reduce using rule 13 (empty -> .) ]

    function                       shift and go to state 6
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 4

    (3) simpleAssignment -> ID . ASSIGN term SEMICOLON statement

    ASSIGN          shift and go to state 10


state 5

    (4) simpleAssignment -> empty .

    TYPE            reduce using rule 4 (simpleAssignment -> empty .)
    $end            reduce using rule 4 (simpleAssignment -> empty .)


state 6

    (2) statement -> simpleAssignment function .

    $end            reduce using rule 2 (statement -> simpleAssignment function .)
    TYPE            reduce using rule 2 (statement -> simpleAssignment function .)


state 7

    (5) function -> type . statement
    (2) statement -> . simpleAssignment function
    (3) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (4) simpleAssignment -> . empty
    (13) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 13 (empty -> .)
    TYPE            reduce using rule 13 (empty -> .)

    statement                      shift and go to state 11
    simpleAssignment               shift and go to state 3
    empty                          shift and go to state 5

state 8

    (6) function -> empty .

    $end            reduce using rule 6 (function -> empty .)
    TYPE            reduce using rule 6 (function -> empty .)


state 9

    (7) type -> TYPE . LPARENT ID RPARENT SEMICOLON

    LPARENT         shift and go to state 12


state 10

    (3) simpleAssignment -> ID ASSIGN . term SEMICOLON statement
    (8) term -> . FALSE
    (9) term -> . TRUE
    (10) term -> . factor
    (11) factor -> . ID
    (12) factor -> . INT

    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    ID              shift and go to state 13
    INT             shift and go to state 18

    term                           shift and go to state 14
    factor                         shift and go to state 17

state 11

    (5) function -> type statement .

    $end            reduce using rule 5 (function -> type statement .)
    TYPE            reduce using rule 5 (function -> type statement .)


state 12

    (7) type -> TYPE LPARENT . ID RPARENT SEMICOLON

    ID              shift and go to state 19


state 13

    (11) factor -> ID .

    SEMICOLON       reduce using rule 11 (factor -> ID .)


state 14

    (3) simpleAssignment -> ID ASSIGN term . SEMICOLON statement

    SEMICOLON       shift and go to state 20


state 15

    (8) term -> FALSE .

    SEMICOLON       reduce using rule 8 (term -> FALSE .)


state 16

    (9) term -> TRUE .

    SEMICOLON       reduce using rule 9 (term -> TRUE .)


state 17

    (10) term -> factor .

    SEMICOLON       reduce using rule 10 (term -> factor .)


state 18

    (12) factor -> INT .

    SEMICOLON       reduce using rule 12 (factor -> INT .)


state 19

    (7) type -> TYPE LPARENT ID . RPARENT SEMICOLON

    RPARENT         shift and go to state 21


state 20

    (3) simpleAssignment -> ID ASSIGN term SEMICOLON . statement
    (2) statement -> . simpleAssignment function
    (3) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (4) simpleAssignment -> . empty
    (13) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 13 (empty -> .)
    TYPE            reduce using rule 13 (empty -> .)

    statement                      shift and go to state 22
    simpleAssignment               shift and go to state 3
    empty                          shift and go to state 5

state 21

    (7) type -> TYPE LPARENT ID RPARENT . SEMICOLON

    SEMICOLON       shift and go to state 23


state 22

    (3) simpleAssignment -> ID ASSIGN term SEMICOLON statement .

    TYPE            reduce using rule 3 (simpleAssignment -> ID ASSIGN term SEMICOLON statement .)
    $end            reduce using rule 3 (simpleAssignment -> ID ASSIGN term SEMICOLON statement .)


state 23

    (7) type -> TYPE LPARENT ID RPARENT SEMICOLON .

    ID              reduce using rule 7 (type -> TYPE LPARENT ID RPARENT SEMICOLON .)
    TYPE            reduce using rule 7 (type -> TYPE LPARENT ID RPARENT SEMICOLON .)
    $end            reduce using rule 7 (type -> TYPE LPARENT ID RPARENT SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
