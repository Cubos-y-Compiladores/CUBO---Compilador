Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLINK
    BOOKED
    CONST
    DELETE
    DIVENT
    DIVIDE
    DOT
    ELSE
    EXP
    F
    FOR
    GLOBAL
    GT
    GTE
    IF
    INSERT
    LCORCH
    LEN
    LENGHTERROR
    LT
    LTE
    MINUS
    MOD
    NE
    NEG
    PARENTCL
    PARENTCR
    PLUS
    PROCEDURE
    RANGE
    RCORCH
    T
    TIMES
    TP
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     statement -> assignment function
Rule 3     assignment -> ID ASSIGN term SEMICOLON statement
Rule 4     assignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
Rule 5     assignment -> empty
Rule 6     function -> type
Rule 7     function -> empty
Rule 8     type -> TYPE LPARENT ID RPARENT SEMICOLON statement
Rule 9     term -> FALSE
Rule 10    term -> TRUE
Rule 11    term -> factor
Rule 12    factor -> ID
Rule 13    factor -> INT
Rule 14    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 3 4
BLINK                : 
BOOKED               : 
COMMA                : 4 4
CONST                : 
DELETE               : 
DIVENT               : 
DIVIDE               : 
DOT                  : 
ELSE                 : 
EXP                  : 
F                    : 
FALSE                : 9
FOR                  : 
GLOBAL               : 
GT                   : 
GTE                  : 
ID                   : 3 4 4 8 12
IF                   : 
INSERT               : 
INT                  : 13
LCORCH               : 
LEN                  : 
LENGHTERROR          : 
LPARENT              : 8
LT                   : 
LTE                  : 
MINUS                : 
MOD                  : 
NE                   : 
NEG                  : 
PARENTCL             : 
PARENTCR             : 
PLUS                 : 
PROCEDURE            : 
RANGE                : 
RCORCH               : 
RPARENT              : 8
SEMICOLON            : 3 4 8
T                    : 
TIMES                : 
TP                   : 
TRUE                 : 10
TYPE                 : 8
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

assignment           : 2
empty                : 5 7
factor               : 11
function             : 2
program              : 0
statement            : 1 3 4 8
term                 : 3 4 4
type                 : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) statement -> . assignment function
    (3) assignment -> . ID ASSIGN term SEMICOLON statement
    (4) assignment -> . ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
    (5) assignment -> . empty
    (14) empty -> .

    ID              shift and go to state 4
    TYPE            reduce using rule 14 (empty -> .)
    $end            reduce using rule 14 (empty -> .)

    program                        shift and go to state 1
    statement                      shift and go to state 2
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) statement -> assignment . function
    (6) function -> . type
    (7) function -> . empty
    (8) type -> . TYPE LPARENT ID RPARENT SEMICOLON statement
    (14) empty -> .

  ! shift/reduce conflict for TYPE resolved as shift
    TYPE            shift and go to state 9
    $end            reduce using rule 14 (empty -> .)

  ! TYPE            [ reduce using rule 14 (empty -> .) ]

    function                       shift and go to state 6
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 4

    (3) assignment -> ID . ASSIGN term SEMICOLON statement
    (4) assignment -> ID . COMMA ID ASSIGN term COMMA term SEMICOLON statement

    ASSIGN          shift and go to state 10
    COMMA           shift and go to state 11


state 5

    (5) assignment -> empty .

    TYPE            reduce using rule 5 (assignment -> empty .)
    $end            reduce using rule 5 (assignment -> empty .)


state 6

    (2) statement -> assignment function .

    $end            reduce using rule 2 (statement -> assignment function .)
    TYPE            reduce using rule 2 (statement -> assignment function .)


state 7

    (6) function -> type .

    $end            reduce using rule 6 (function -> type .)
    TYPE            reduce using rule 6 (function -> type .)


state 8

    (7) function -> empty .

    $end            reduce using rule 7 (function -> empty .)
    TYPE            reduce using rule 7 (function -> empty .)


state 9

    (8) type -> TYPE . LPARENT ID RPARENT SEMICOLON statement

    LPARENT         shift and go to state 12


state 10

    (3) assignment -> ID ASSIGN . term SEMICOLON statement
    (9) term -> . FALSE
    (10) term -> . TRUE
    (11) term -> . factor
    (12) factor -> . ID
    (13) factor -> . INT

    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    ID              shift and go to state 13
    INT             shift and go to state 18

    term                           shift and go to state 14
    factor                         shift and go to state 17

state 11

    (4) assignment -> ID COMMA . ID ASSIGN term COMMA term SEMICOLON statement

    ID              shift and go to state 19


state 12

    (8) type -> TYPE LPARENT . ID RPARENT SEMICOLON statement

    ID              shift and go to state 20


state 13

    (12) factor -> ID .

    SEMICOLON       reduce using rule 12 (factor -> ID .)
    COMMA           reduce using rule 12 (factor -> ID .)


state 14

    (3) assignment -> ID ASSIGN term . SEMICOLON statement

    SEMICOLON       shift and go to state 21


state 15

    (9) term -> FALSE .

    SEMICOLON       reduce using rule 9 (term -> FALSE .)
    COMMA           reduce using rule 9 (term -> FALSE .)


state 16

    (10) term -> TRUE .

    SEMICOLON       reduce using rule 10 (term -> TRUE .)
    COMMA           reduce using rule 10 (term -> TRUE .)


state 17

    (11) term -> factor .

    SEMICOLON       reduce using rule 11 (term -> factor .)
    COMMA           reduce using rule 11 (term -> factor .)


state 18

    (13) factor -> INT .

    SEMICOLON       reduce using rule 13 (factor -> INT .)
    COMMA           reduce using rule 13 (factor -> INT .)


state 19

    (4) assignment -> ID COMMA ID . ASSIGN term COMMA term SEMICOLON statement

    ASSIGN          shift and go to state 22


state 20

    (8) type -> TYPE LPARENT ID . RPARENT SEMICOLON statement

    RPARENT         shift and go to state 23


state 21

    (3) assignment -> ID ASSIGN term SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . ID ASSIGN term SEMICOLON statement
    (4) assignment -> . ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
    (5) assignment -> . empty
    (14) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 14 (empty -> .)
    TYPE            reduce using rule 14 (empty -> .)

    statement                      shift and go to state 24
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 22

    (4) assignment -> ID COMMA ID ASSIGN . term COMMA term SEMICOLON statement
    (9) term -> . FALSE
    (10) term -> . TRUE
    (11) term -> . factor
    (12) factor -> . ID
    (13) factor -> . INT

    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    ID              shift and go to state 13
    INT             shift and go to state 18

    term                           shift and go to state 25
    factor                         shift and go to state 17

state 23

    (8) type -> TYPE LPARENT ID RPARENT . SEMICOLON statement

    SEMICOLON       shift and go to state 26


state 24

    (3) assignment -> ID ASSIGN term SEMICOLON statement .

    TYPE            reduce using rule 3 (assignment -> ID ASSIGN term SEMICOLON statement .)
    $end            reduce using rule 3 (assignment -> ID ASSIGN term SEMICOLON statement .)


state 25

    (4) assignment -> ID COMMA ID ASSIGN term . COMMA term SEMICOLON statement

    COMMA           shift and go to state 27


state 26

    (8) type -> TYPE LPARENT ID RPARENT SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . ID ASSIGN term SEMICOLON statement
    (4) assignment -> . ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
    (5) assignment -> . empty
    (14) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 14 (empty -> .)
    TYPE            reduce using rule 14 (empty -> .)

    statement                      shift and go to state 28
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 27

    (4) assignment -> ID COMMA ID ASSIGN term COMMA . term SEMICOLON statement
    (9) term -> . FALSE
    (10) term -> . TRUE
    (11) term -> . factor
    (12) factor -> . ID
    (13) factor -> . INT

    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    ID              shift and go to state 13
    INT             shift and go to state 18

    term                           shift and go to state 29
    factor                         shift and go to state 17

state 28

    (8) type -> TYPE LPARENT ID RPARENT SEMICOLON statement .

    $end            reduce using rule 8 (type -> TYPE LPARENT ID RPARENT SEMICOLON statement .)
    TYPE            reduce using rule 8 (type -> TYPE LPARENT ID RPARENT SEMICOLON statement .)


state 29

    (4) assignment -> ID COMMA ID ASSIGN term COMMA term . SEMICOLON statement

    SEMICOLON       shift and go to state 30


state 30

    (4) assignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . ID ASSIGN term SEMICOLON statement
    (4) assignment -> . ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
    (5) assignment -> . empty
    (14) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 14 (empty -> .)
    TYPE            reduce using rule 14 (empty -> .)

    statement                      shift and go to state 31
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 31

    (4) assignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .

    TYPE            reduce using rule 4 (assignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .)
    $end            reduce using rule 4 (assignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
