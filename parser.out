Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOKED
    CALL
    CONST
    ELSE
    IF
    LENGHTERROR
    MAIN
    PROCEDURE
    SHAPEA
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> const_block
Rule 2     const_block -> const const const const const block
Rule 3     block -> assignment
Rule 4     block -> function
Rule 5     block -> consult SEMICOLON block
Rule 6     block -> cycle
Rule 7     assignment -> identifier ASSIGN a_content SEMICOLON block
Rule 8     assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block
Rule 9     assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block
Rule 10    assignment -> empty
Rule 11    function -> type
Rule 12    function -> insert
Rule 13    function -> del
Rule 14    function -> len
Rule 15    function -> neg
Rule 16    function -> t_f
Rule 17    function -> blink
Rule 18    function -> delay
Rule 19    function -> shape
Rule 20    type -> TYPE LPARENT ID RPARENT SEMICOLON block
Rule 21    a_content -> RANGE LPARENT INT COMMA value RPARENT
Rule 22    insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
Rule 23    del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
Rule 24    len -> LEN LPARENT ID RPARENT SEMICOLON block
Rule 25    neg -> consult DOT NEG SEMICOLON block
Rule 26    t_f -> consult DOT tf SEMICOLON block
Rule 27    blink -> BLINK LPARENT b_content RPARENT SEMICOLON block
Rule 28    delay -> DELAY LPARENT d_content RPARENT SEMICOLON block
Rule 29    shape_arg -> SHAPEF
Rule 30    shape_arg -> SHAPEC
Rule 31    shape -> ID DOT shape_arg SEMICOLON block
Rule 32    cycle -> for
Rule 33    for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
Rule 34    step -> STEP INT
Rule 35    step -> empty
Rule 36    arithmetic -> term
Rule 37    arithmetic -> adding_operator term
Rule 38    arithmetic -> arithmetic adding_operator term
Rule 39    term -> factor
Rule 40    term -> term multiplying_operator factor
Rule 41    factor -> INT
Rule 42    factor -> ID
Rule 43    factor -> LPARENT arithmetic RPARENT
Rule 44    const -> TIMER ASSIGN INT SEMICOLON
Rule 45    const -> RANGOTIMER ASSIGN time_mes SEMICOLON
Rule 46    const -> dimension ASSIGN INT SEMICOLON
Rule 47    const -> CUBO ASSIGN INT SEMICOLON
Rule 48    a_content -> value
Rule 49    a_content -> arithmetic
Rule 50    a_content -> list
Rule 51    b_content -> complex_id COMMA INT COMMA time_mes COMMA value
Rule 52    b_content -> complex_id COMMA value
Rule 53    d_content -> empty
Rule 54    d_content -> INT COMMA time_mes
Rule 55    tf -> T
Rule 56    tf -> F
Rule 57    list -> PARENTCL list_term PARENTCR
Rule 58    list -> PARENTCL empty PARENTCR
Rule 59    list_term -> list_value COMMA list_term
Rule 60    list_term -> list_value
Rule 61    list_value -> value
Rule 62    list_value -> list
Rule 63    consult -> list_consult
Rule 64    consult -> mat_consult
Rule 65    list_consult -> complex_id
Rule 66    mat_consult -> ID PARENTCL indice COMMA indice PARENTCR
Rule 67    mat_consult -> ID PARENTCL TP COMMA indice PARENTCR
Rule 68    indice -> INT
Rule 69    indice -> ID
Rule 70    dimension -> DIMFILAS
Rule 71    dimension -> DIMCOLUMNAS
Rule 72    time_mes -> QUOTES MIL QUOTES
Rule 73    time_mes -> QUOTES MIN QUOTES
Rule 74    time_mes -> QUOTES SEG QUOTES
Rule 75    adding_operator -> PLUS
Rule 76    adding_operator -> MINUS
Rule 77    multiplying_operator -> TIMES
Rule 78    multiplying_operator -> EXP
Rule 79    multiplying_operator -> DIVIDE
Rule 80    multiplying_operator -> DIVENT
Rule 81    multiplying_operator -> MOD
Rule 82    value -> FALSE
Rule 83    value -> TRUE
Rule 84    relation -> ASSIGN
Rule 85    relation -> NE
Rule 86    relation -> LT
Rule 87    relation -> GT
Rule 88    relation -> LTE
Rule 89    relation -> GTE
Rule 90    identifier -> ID
Rule 91    identifier -> complex_id
Rule 92    complex_id -> ID PARENTCL indice PARENTCR
Rule 93    complex_id -> ID PARENTCL indice TP indice PARENTCR
Rule 94    iterable -> identifier
Rule 95    iterable -> INT
Rule 96    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 7 8 9 44 45 46 47 84
BLINK                : 27
BOOKED               : 
CALL                 : 
COMMA                : 9 9 21 22 51 51 51 52 54 59 66 67
CONST                : 
CUBO                 : 47
DELAY                : 28
DELETE               : 23
DIMCOLUMNAS          : 71
DIMFILAS             : 70
DIVENT               : 80
DIVIDE               : 79
DOT                  : 22 23 25 26 31
ELSE                 : 
EXP                  : 78
F                    : 56
FALSE                : 82
FOR                  : 33
GLOBAL               : 8
GT                   : 87
GTE                  : 89
ID                   : 8 9 9 20 22 23 24 31 33 42 66 67 69 90 92 93
IF                   : 
IN                   : 33
INSERT               : 22
INT                  : 21 22 23 34 41 44 46 47 51 54 68 95
LCORCH               : 33
LEN                  : 24
LENGHTERROR          : 
LPARENT              : 20 21 22 23 24 27 28 43
LT                   : 86
LTE                  : 88
MAIN                 : 
MIL                  : 72
MIN                  : 73
MINUS                : 76
MOD                  : 81
NE                   : 85
NEG                  : 25
PARENTCL             : 57 58 66 67 92 93
PARENTCR             : 57 58 66 67 92 93
PLUS                 : 75
PROCEDURE            : 
QUOTES               : 72 72 73 73 74 74
RANGE                : 21
RANGOTIMER           : 45
RCORCH               : 33
RPARENT              : 20 21 22 23 24 27 28 43
SEG                  : 74
SEMICOLON            : 5 7 8 9 20 22 23 24 25 26 27 28 31 33 44 45 46 47
SHAPEA               : 
SHAPEC               : 30
SHAPEF               : 29
STEP                 : 34
T                    : 55
TIMER                : 44
TIMES                : 77
TP                   : 67 93
TRUE                 : 83
TYPE                 : 20
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

a_content            : 7 8
adding_operator      : 37 38
arithmetic           : 38 43 49
assignment           : 3
b_content            : 27
blink                : 17
block                : 2 5 7 8 9 20 22 23 24 25 26 27 28 31 33 33
complex_id           : 51 52 65 91
const                : 2 2 2 2 2
const_block          : 1
consult              : 5 25 26
cycle                : 6
d_content            : 28
del                  : 13
delay                : 18
dimension            : 46
empty                : 10 35 53 58
factor               : 39 40
for                  : 32
function             : 4
identifier           : 7 94
indice               : 66 66 67 92 93 93
insert               : 12
iterable             : 33
len                  : 14
list                 : 50 62
list_consult         : 63
list_term            : 57 59
list_value           : 59 60
mat_consult          : 64
multiplying_operator : 40
neg                  : 15
program              : 0
relation             : 
shape                : 19
shape_arg            : 31
step                 : 33
t_f                  : 16
term                 : 36 37 38 40
tf                   : 26
time_mes             : 45 51 54
type                 : 11
value                : 9 9 21 22 48 51 52 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . const_block
    (2) const_block -> . const const const const const block
    (44) const -> . TIMER ASSIGN INT SEMICOLON
    (45) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (46) const -> . dimension ASSIGN INT SEMICOLON
    (47) const -> . CUBO ASSIGN INT SEMICOLON
    (70) dimension -> . DIMFILAS
    (71) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    program                        shift and go to state 1
    const_block                    shift and go to state 2
    const                          shift and go to state 3
    dimension                      shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> const_block .

    $end            reduce using rule 1 (program -> const_block .)


state 3

    (2) const_block -> const . const const const const block
    (44) const -> . TIMER ASSIGN INT SEMICOLON
    (45) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (46) const -> . dimension ASSIGN INT SEMICOLON
    (47) const -> . CUBO ASSIGN INT SEMICOLON
    (70) dimension -> . DIMFILAS
    (71) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 10
    dimension                      shift and go to state 6

state 4

    (44) const -> TIMER . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 11


state 5

    (45) const -> RANGOTIMER . ASSIGN time_mes SEMICOLON

    ASSIGN          shift and go to state 12


state 6

    (46) const -> dimension . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 13


state 7

    (47) const -> CUBO . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 14


state 8

    (70) dimension -> DIMFILAS .

    ASSIGN          reduce using rule 70 (dimension -> DIMFILAS .)


state 9

    (71) dimension -> DIMCOLUMNAS .

    ASSIGN          reduce using rule 71 (dimension -> DIMCOLUMNAS .)


state 10

    (2) const_block -> const const . const const const block
    (44) const -> . TIMER ASSIGN INT SEMICOLON
    (45) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (46) const -> . dimension ASSIGN INT SEMICOLON
    (47) const -> . CUBO ASSIGN INT SEMICOLON
    (70) dimension -> . DIMFILAS
    (71) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 15
    dimension                      shift and go to state 6

state 11

    (44) const -> TIMER ASSIGN . INT SEMICOLON

    INT             shift and go to state 16


state 12

    (45) const -> RANGOTIMER ASSIGN . time_mes SEMICOLON
    (72) time_mes -> . QUOTES MIL QUOTES
    (73) time_mes -> . QUOTES MIN QUOTES
    (74) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 17

state 13

    (46) const -> dimension ASSIGN . INT SEMICOLON

    INT             shift and go to state 19


state 14

    (47) const -> CUBO ASSIGN . INT SEMICOLON

    INT             shift and go to state 20


state 15

    (2) const_block -> const const const . const const block
    (44) const -> . TIMER ASSIGN INT SEMICOLON
    (45) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (46) const -> . dimension ASSIGN INT SEMICOLON
    (47) const -> . CUBO ASSIGN INT SEMICOLON
    (70) dimension -> . DIMFILAS
    (71) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 21
    dimension                      shift and go to state 6

state 16

    (44) const -> TIMER ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 22


state 17

    (45) const -> RANGOTIMER ASSIGN time_mes . SEMICOLON

    SEMICOLON       shift and go to state 23


state 18

    (72) time_mes -> QUOTES . MIL QUOTES
    (73) time_mes -> QUOTES . MIN QUOTES
    (74) time_mes -> QUOTES . SEG QUOTES

    MIL             shift and go to state 24
    MIN             shift and go to state 25
    SEG             shift and go to state 26


state 19

    (46) const -> dimension ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 27


state 20

    (47) const -> CUBO ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 28


state 21

    (2) const_block -> const const const const . const block
    (44) const -> . TIMER ASSIGN INT SEMICOLON
    (45) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (46) const -> . dimension ASSIGN INT SEMICOLON
    (47) const -> . CUBO ASSIGN INT SEMICOLON
    (70) dimension -> . DIMFILAS
    (71) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 29
    dimension                      shift and go to state 6

state 22

    (44) const -> TIMER ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    ID              reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)
    $end            reduce using rule 44 (const -> TIMER ASSIGN INT SEMICOLON .)


state 23

    (45) const -> RANGOTIMER ASSIGN time_mes SEMICOLON .

    TIMER           reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    RANGOTIMER      reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    CUBO            reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DIMFILAS        reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    GLOBAL          reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    ID              reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    TYPE            reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    LEN             reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    BLINK           reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DELAY           reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    FOR             reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    $end            reduce using rule 45 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)


state 24

    (72) time_mes -> QUOTES MIL . QUOTES

    QUOTES          shift and go to state 30


state 25

    (73) time_mes -> QUOTES MIN . QUOTES

    QUOTES          shift and go to state 31


state 26

    (74) time_mes -> QUOTES SEG . QUOTES

    QUOTES          shift and go to state 32


state 27

    (46) const -> dimension ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    ID              reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)
    $end            reduce using rule 46 (const -> dimension ASSIGN INT SEMICOLON .)


state 28

    (47) const -> CUBO ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    ID              reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)
    $end            reduce using rule 47 (const -> CUBO ASSIGN INT SEMICOLON .)


state 29

    (2) const_block -> const const const const const . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 33
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 30

    (72) time_mes -> QUOTES MIL QUOTES .

    SEMICOLON       reduce using rule 72 (time_mes -> QUOTES MIL QUOTES .)
    RPARENT         reduce using rule 72 (time_mes -> QUOTES MIL QUOTES .)
    COMMA           reduce using rule 72 (time_mes -> QUOTES MIL QUOTES .)


state 31

    (73) time_mes -> QUOTES MIN QUOTES .

    SEMICOLON       reduce using rule 73 (time_mes -> QUOTES MIN QUOTES .)
    RPARENT         reduce using rule 73 (time_mes -> QUOTES MIN QUOTES .)
    COMMA           reduce using rule 73 (time_mes -> QUOTES MIN QUOTES .)


state 32

    (74) time_mes -> QUOTES SEG QUOTES .

    SEMICOLON       reduce using rule 74 (time_mes -> QUOTES SEG QUOTES .)
    RPARENT         reduce using rule 74 (time_mes -> QUOTES SEG QUOTES .)
    COMMA           reduce using rule 74 (time_mes -> QUOTES SEG QUOTES .)


state 33

    (2) const_block -> const const const const const block .

    $end            reduce using rule 2 (const_block -> const const const const const block .)


state 34

    (3) block -> assignment .

    $end            reduce using rule 3 (block -> assignment .)
    RCORCH          reduce using rule 3 (block -> assignment .)


state 35

    (4) block -> function .

    $end            reduce using rule 4 (block -> function .)
    RCORCH          reduce using rule 4 (block -> function .)


state 36

    (5) block -> consult . SEMICOLON block
    (25) neg -> consult . DOT NEG SEMICOLON block
    (26) t_f -> consult . DOT tf SEMICOLON block

    SEMICOLON       shift and go to state 60
    DOT             shift and go to state 61


state 37

    (6) block -> cycle .

    $end            reduce using rule 6 (block -> cycle .)
    RCORCH          reduce using rule 6 (block -> cycle .)


state 38

    (7) assignment -> identifier . ASSIGN a_content SEMICOLON block

    ASSIGN          shift and go to state 62


state 39

    (8) assignment -> GLOBAL . ID ASSIGN a_content SEMICOLON block

    ID              shift and go to state 63


state 40

    (9) assignment -> ID . COMMA ID ASSIGN value COMMA value SEMICOLON block
    (90) identifier -> ID .
    (22) insert -> ID . DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> ID . DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (31) shape -> ID . DOT shape_arg SEMICOLON block
    (66) mat_consult -> ID . PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> ID . PARENTCL TP COMMA indice PARENTCR
    (92) complex_id -> ID . PARENTCL indice PARENTCR
    (93) complex_id -> ID . PARENTCL indice TP indice PARENTCR

    COMMA           shift and go to state 64
    ASSIGN          reduce using rule 90 (identifier -> ID .)
    DOT             shift and go to state 65
    PARENTCL        shift and go to state 66


state 41

    (10) assignment -> empty .

    $end            reduce using rule 10 (assignment -> empty .)
    RCORCH          reduce using rule 10 (assignment -> empty .)


state 42

    (11) function -> type .

    $end            reduce using rule 11 (function -> type .)
    RCORCH          reduce using rule 11 (function -> type .)


state 43

    (12) function -> insert .

    $end            reduce using rule 12 (function -> insert .)
    RCORCH          reduce using rule 12 (function -> insert .)


state 44

    (13) function -> del .

    $end            reduce using rule 13 (function -> del .)
    RCORCH          reduce using rule 13 (function -> del .)


state 45

    (14) function -> len .

    $end            reduce using rule 14 (function -> len .)
    RCORCH          reduce using rule 14 (function -> len .)


state 46

    (15) function -> neg .

    $end            reduce using rule 15 (function -> neg .)
    RCORCH          reduce using rule 15 (function -> neg .)


state 47

    (16) function -> t_f .

    $end            reduce using rule 16 (function -> t_f .)
    RCORCH          reduce using rule 16 (function -> t_f .)


state 48

    (17) function -> blink .

    $end            reduce using rule 17 (function -> blink .)
    RCORCH          reduce using rule 17 (function -> blink .)


state 49

    (18) function -> delay .

    $end            reduce using rule 18 (function -> delay .)
    RCORCH          reduce using rule 18 (function -> delay .)


state 50

    (19) function -> shape .

    $end            reduce using rule 19 (function -> shape .)
    RCORCH          reduce using rule 19 (function -> shape .)


state 51

    (63) consult -> list_consult .

    SEMICOLON       reduce using rule 63 (consult -> list_consult .)
    DOT             reduce using rule 63 (consult -> list_consult .)


state 52

    (64) consult -> mat_consult .

    SEMICOLON       reduce using rule 64 (consult -> mat_consult .)
    DOT             reduce using rule 64 (consult -> mat_consult .)


state 53

    (32) cycle -> for .

    $end            reduce using rule 32 (cycle -> for .)
    RCORCH          reduce using rule 32 (cycle -> for .)


state 54

    (91) identifier -> complex_id .
    (65) list_consult -> complex_id .

    ASSIGN          reduce using rule 91 (identifier -> complex_id .)
    SEMICOLON       reduce using rule 65 (list_consult -> complex_id .)
    DOT             reduce using rule 65 (list_consult -> complex_id .)


state 55

    (20) type -> TYPE . LPARENT ID RPARENT SEMICOLON block

    LPARENT         shift and go to state 67


state 56

    (24) len -> LEN . LPARENT ID RPARENT SEMICOLON block

    LPARENT         shift and go to state 68


state 57

    (27) blink -> BLINK . LPARENT b_content RPARENT SEMICOLON block

    LPARENT         shift and go to state 69


state 58

    (28) delay -> DELAY . LPARENT d_content RPARENT SEMICOLON block

    LPARENT         shift and go to state 70


state 59

    (33) for -> FOR . ID IN iterable step LCORCH block RCORCH SEMICOLON block

    ID              shift and go to state 71


state 60

    (5) block -> consult SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    consult                        shift and go to state 36
    block                          shift and go to state 72
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 61

    (25) neg -> consult DOT . NEG SEMICOLON block
    (26) t_f -> consult DOT . tf SEMICOLON block
    (55) tf -> . T
    (56) tf -> . F

    NEG             shift and go to state 73
    T               shift and go to state 75
    F               shift and go to state 76

    tf                             shift and go to state 74

state 62

    (7) assignment -> identifier ASSIGN . a_content SEMICOLON block
    (21) a_content -> . RANGE LPARENT INT COMMA value RPARENT
    (48) a_content -> . value
    (49) a_content -> . arithmetic
    (50) a_content -> . list
    (82) value -> . FALSE
    (83) value -> . TRUE
    (36) arithmetic -> . term
    (37) arithmetic -> . adding_operator term
    (38) arithmetic -> . arithmetic adding_operator term
    (57) list -> . PARENTCL list_term PARENTCR
    (58) list -> . PARENTCL empty PARENTCR
    (39) term -> . factor
    (40) term -> . term multiplying_operator factor
    (75) adding_operator -> . PLUS
    (76) adding_operator -> . MINUS
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    RANGE           shift and go to state 78
    FALSE           shift and go to state 84
    TRUE            shift and go to state 85
    PARENTCL        shift and go to state 88
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    a_content                      shift and go to state 77
    value                          shift and go to state 81
    arithmetic                     shift and go to state 82
    list                           shift and go to state 83
    term                           shift and go to state 86
    adding_operator                shift and go to state 87
    factor                         shift and go to state 89

state 63

    (8) assignment -> GLOBAL ID . ASSIGN a_content SEMICOLON block

    ASSIGN          shift and go to state 93


state 64

    (9) assignment -> ID COMMA . ID ASSIGN value COMMA value SEMICOLON block

    ID              shift and go to state 94


state 65

    (22) insert -> ID DOT . INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> ID DOT . DELETE LPARENT INT RPARENT SEMICOLON block
    (31) shape -> ID DOT . shape_arg SEMICOLON block
    (29) shape_arg -> . SHAPEF
    (30) shape_arg -> . SHAPEC

    INSERT          shift and go to state 95
    DELETE          shift and go to state 96
    SHAPEF          shift and go to state 98
    SHAPEC          shift and go to state 99

    shape_arg                      shift and go to state 97

state 66

    (66) mat_consult -> ID PARENTCL . indice COMMA indice PARENTCR
    (67) mat_consult -> ID PARENTCL . TP COMMA indice PARENTCR
    (92) complex_id -> ID PARENTCL . indice PARENTCR
    (93) complex_id -> ID PARENTCL . indice TP indice PARENTCR
    (68) indice -> . INT
    (69) indice -> . ID

    TP              shift and go to state 102
    INT             shift and go to state 103
    ID              shift and go to state 100

    indice                         shift and go to state 101

state 67

    (20) type -> TYPE LPARENT . ID RPARENT SEMICOLON block

    ID              shift and go to state 104


state 68

    (24) len -> LEN LPARENT . ID RPARENT SEMICOLON block

    ID              shift and go to state 105


state 69

    (27) blink -> BLINK LPARENT . b_content RPARENT SEMICOLON block
    (51) b_content -> . complex_id COMMA INT COMMA time_mes COMMA value
    (52) b_content -> . complex_id COMMA value
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    ID              shift and go to state 108

    b_content                      shift and go to state 106
    complex_id                     shift and go to state 107

state 70

    (28) delay -> DELAY LPARENT . d_content RPARENT SEMICOLON block
    (53) d_content -> . empty
    (54) d_content -> . INT COMMA time_mes
    (96) empty -> .

    INT             shift and go to state 111
    RPARENT         reduce using rule 96 (empty -> .)

    d_content                      shift and go to state 109
    empty                          shift and go to state 110

state 71

    (33) for -> FOR ID . IN iterable step LCORCH block RCORCH SEMICOLON block

    IN              shift and go to state 112


state 72

    (5) block -> consult SEMICOLON block .

    $end            reduce using rule 5 (block -> consult SEMICOLON block .)
    RCORCH          reduce using rule 5 (block -> consult SEMICOLON block .)


state 73

    (25) neg -> consult DOT NEG . SEMICOLON block

    SEMICOLON       shift and go to state 113


state 74

    (26) t_f -> consult DOT tf . SEMICOLON block

    SEMICOLON       shift and go to state 114


state 75

    (55) tf -> T .

    SEMICOLON       reduce using rule 55 (tf -> T .)


state 76

    (56) tf -> F .

    SEMICOLON       reduce using rule 56 (tf -> F .)


state 77

    (7) assignment -> identifier ASSIGN a_content . SEMICOLON block

    SEMICOLON       shift and go to state 115


state 78

    (21) a_content -> RANGE . LPARENT INT COMMA value RPARENT

    LPARENT         shift and go to state 116


state 79

    (43) factor -> LPARENT . arithmetic RPARENT
    (36) arithmetic -> . term
    (37) arithmetic -> . adding_operator term
    (38) arithmetic -> . arithmetic adding_operator term
    (39) term -> . factor
    (40) term -> . term multiplying_operator factor
    (75) adding_operator -> . PLUS
    (76) adding_operator -> . MINUS
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    arithmetic                     shift and go to state 117
    term                           shift and go to state 86
    adding_operator                shift and go to state 87
    factor                         shift and go to state 89

state 80

    (41) factor -> INT .

    TIMES           reduce using rule 41 (factor -> INT .)
    EXP             reduce using rule 41 (factor -> INT .)
    DIVIDE          reduce using rule 41 (factor -> INT .)
    DIVENT          reduce using rule 41 (factor -> INT .)
    MOD             reduce using rule 41 (factor -> INT .)
    PLUS            reduce using rule 41 (factor -> INT .)
    MINUS           reduce using rule 41 (factor -> INT .)
    SEMICOLON       reduce using rule 41 (factor -> INT .)
    RPARENT         reduce using rule 41 (factor -> INT .)


state 81

    (48) a_content -> value .

    SEMICOLON       reduce using rule 48 (a_content -> value .)


state 82

    (49) a_content -> arithmetic .
    (38) arithmetic -> arithmetic . adding_operator term
    (75) adding_operator -> . PLUS
    (76) adding_operator -> . MINUS

    SEMICOLON       reduce using rule 49 (a_content -> arithmetic .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91

    adding_operator                shift and go to state 118

state 83

    (50) a_content -> list .

    SEMICOLON       reduce using rule 50 (a_content -> list .)


state 84

    (82) value -> FALSE .

    SEMICOLON       reduce using rule 82 (value -> FALSE .)
    COMMA           reduce using rule 82 (value -> FALSE .)
    PARENTCR        reduce using rule 82 (value -> FALSE .)
    RPARENT         reduce using rule 82 (value -> FALSE .)


state 85

    (83) value -> TRUE .

    SEMICOLON       reduce using rule 83 (value -> TRUE .)
    COMMA           reduce using rule 83 (value -> TRUE .)
    PARENTCR        reduce using rule 83 (value -> TRUE .)
    RPARENT         reduce using rule 83 (value -> TRUE .)


state 86

    (36) arithmetic -> term .
    (40) term -> term . multiplying_operator factor
    (77) multiplying_operator -> . TIMES
    (78) multiplying_operator -> . EXP
    (79) multiplying_operator -> . DIVIDE
    (80) multiplying_operator -> . DIVENT
    (81) multiplying_operator -> . MOD

    PLUS            reduce using rule 36 (arithmetic -> term .)
    MINUS           reduce using rule 36 (arithmetic -> term .)
    SEMICOLON       reduce using rule 36 (arithmetic -> term .)
    RPARENT         reduce using rule 36 (arithmetic -> term .)
    TIMES           shift and go to state 120
    EXP             shift and go to state 121
    DIVIDE          shift and go to state 122
    DIVENT          shift and go to state 123
    MOD             shift and go to state 124

    multiplying_operator           shift and go to state 119

state 87

    (37) arithmetic -> adding_operator . term
    (39) term -> . factor
    (40) term -> . term multiplying_operator factor
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    term                           shift and go to state 125
    factor                         shift and go to state 89

state 88

    (57) list -> PARENTCL . list_term PARENTCR
    (58) list -> PARENTCL . empty PARENTCR
    (59) list_term -> . list_value COMMA list_term
    (60) list_term -> . list_value
    (96) empty -> .
    (61) list_value -> . value
    (62) list_value -> . list
    (82) value -> . FALSE
    (83) value -> . TRUE
    (57) list -> . PARENTCL list_term PARENTCR
    (58) list -> . PARENTCL empty PARENTCR

    PARENTCR        reduce using rule 96 (empty -> .)
    FALSE           shift and go to state 84
    TRUE            shift and go to state 85
    PARENTCL        shift and go to state 88

    list_term                      shift and go to state 126
    empty                          shift and go to state 127
    list_value                     shift and go to state 128
    value                          shift and go to state 129
    list                           shift and go to state 130

state 89

    (39) term -> factor .

    TIMES           reduce using rule 39 (term -> factor .)
    EXP             reduce using rule 39 (term -> factor .)
    DIVIDE          reduce using rule 39 (term -> factor .)
    DIVENT          reduce using rule 39 (term -> factor .)
    MOD             reduce using rule 39 (term -> factor .)
    PLUS            reduce using rule 39 (term -> factor .)
    MINUS           reduce using rule 39 (term -> factor .)
    SEMICOLON       reduce using rule 39 (term -> factor .)
    RPARENT         reduce using rule 39 (term -> factor .)


state 90

    (75) adding_operator -> PLUS .

    INT             reduce using rule 75 (adding_operator -> PLUS .)
    ID              reduce using rule 75 (adding_operator -> PLUS .)
    LPARENT         reduce using rule 75 (adding_operator -> PLUS .)


state 91

    (76) adding_operator -> MINUS .

    INT             reduce using rule 76 (adding_operator -> MINUS .)
    ID              reduce using rule 76 (adding_operator -> MINUS .)
    LPARENT         reduce using rule 76 (adding_operator -> MINUS .)


state 92

    (42) factor -> ID .

    TIMES           reduce using rule 42 (factor -> ID .)
    EXP             reduce using rule 42 (factor -> ID .)
    DIVIDE          reduce using rule 42 (factor -> ID .)
    DIVENT          reduce using rule 42 (factor -> ID .)
    MOD             reduce using rule 42 (factor -> ID .)
    PLUS            reduce using rule 42 (factor -> ID .)
    MINUS           reduce using rule 42 (factor -> ID .)
    SEMICOLON       reduce using rule 42 (factor -> ID .)
    RPARENT         reduce using rule 42 (factor -> ID .)


state 93

    (8) assignment -> GLOBAL ID ASSIGN . a_content SEMICOLON block
    (21) a_content -> . RANGE LPARENT INT COMMA value RPARENT
    (48) a_content -> . value
    (49) a_content -> . arithmetic
    (50) a_content -> . list
    (82) value -> . FALSE
    (83) value -> . TRUE
    (36) arithmetic -> . term
    (37) arithmetic -> . adding_operator term
    (38) arithmetic -> . arithmetic adding_operator term
    (57) list -> . PARENTCL list_term PARENTCR
    (58) list -> . PARENTCL empty PARENTCR
    (39) term -> . factor
    (40) term -> . term multiplying_operator factor
    (75) adding_operator -> . PLUS
    (76) adding_operator -> . MINUS
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    RANGE           shift and go to state 78
    FALSE           shift and go to state 84
    TRUE            shift and go to state 85
    PARENTCL        shift and go to state 88
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    a_content                      shift and go to state 131
    value                          shift and go to state 81
    arithmetic                     shift and go to state 82
    list                           shift and go to state 83
    term                           shift and go to state 86
    adding_operator                shift and go to state 87
    factor                         shift and go to state 89

state 94

    (9) assignment -> ID COMMA ID . ASSIGN value COMMA value SEMICOLON block

    ASSIGN          shift and go to state 132


state 95

    (22) insert -> ID DOT INSERT . LPARENT INT COMMA value RPARENT SEMICOLON block

    LPARENT         shift and go to state 133


state 96

    (23) del -> ID DOT DELETE . LPARENT INT RPARENT SEMICOLON block

    LPARENT         shift and go to state 134


state 97

    (31) shape -> ID DOT shape_arg . SEMICOLON block

    SEMICOLON       shift and go to state 135


state 98

    (29) shape_arg -> SHAPEF .

    SEMICOLON       reduce using rule 29 (shape_arg -> SHAPEF .)


state 99

    (30) shape_arg -> SHAPEC .

    SEMICOLON       reduce using rule 30 (shape_arg -> SHAPEC .)


state 100

    (69) indice -> ID .

    COMMA           reduce using rule 69 (indice -> ID .)
    PARENTCR        reduce using rule 69 (indice -> ID .)
    TP              reduce using rule 69 (indice -> ID .)


state 101

    (66) mat_consult -> ID PARENTCL indice . COMMA indice PARENTCR
    (92) complex_id -> ID PARENTCL indice . PARENTCR
    (93) complex_id -> ID PARENTCL indice . TP indice PARENTCR

    COMMA           shift and go to state 136
    PARENTCR        shift and go to state 137
    TP              shift and go to state 138


state 102

    (67) mat_consult -> ID PARENTCL TP . COMMA indice PARENTCR

    COMMA           shift and go to state 139


state 103

    (68) indice -> INT .

    COMMA           reduce using rule 68 (indice -> INT .)
    PARENTCR        reduce using rule 68 (indice -> INT .)
    TP              reduce using rule 68 (indice -> INT .)


state 104

    (20) type -> TYPE LPARENT ID . RPARENT SEMICOLON block

    RPARENT         shift and go to state 140


state 105

    (24) len -> LEN LPARENT ID . RPARENT SEMICOLON block

    RPARENT         shift and go to state 141


state 106

    (27) blink -> BLINK LPARENT b_content . RPARENT SEMICOLON block

    RPARENT         shift and go to state 142


state 107

    (51) b_content -> complex_id . COMMA INT COMMA time_mes COMMA value
    (52) b_content -> complex_id . COMMA value

    COMMA           shift and go to state 143


state 108

    (92) complex_id -> ID . PARENTCL indice PARENTCR
    (93) complex_id -> ID . PARENTCL indice TP indice PARENTCR

    PARENTCL        shift and go to state 144


state 109

    (28) delay -> DELAY LPARENT d_content . RPARENT SEMICOLON block

    RPARENT         shift and go to state 145


state 110

    (53) d_content -> empty .

    RPARENT         reduce using rule 53 (d_content -> empty .)


state 111

    (54) d_content -> INT . COMMA time_mes

    COMMA           shift and go to state 146


state 112

    (33) for -> FOR ID IN . iterable step LCORCH block RCORCH SEMICOLON block
    (94) iterable -> . identifier
    (95) iterable -> . INT
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    INT             shift and go to state 150
    ID              shift and go to state 147

    iterable                       shift and go to state 148
    identifier                     shift and go to state 149
    complex_id                     shift and go to state 151

state 113

    (25) neg -> consult DOT NEG SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    consult                        shift and go to state 36
    block                          shift and go to state 152
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 114

    (26) t_f -> consult DOT tf SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    consult                        shift and go to state 36
    block                          shift and go to state 153
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 115

    (7) assignment -> identifier ASSIGN a_content SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    identifier                     shift and go to state 38
    block                          shift and go to state 154
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 116

    (21) a_content -> RANGE LPARENT . INT COMMA value RPARENT

    INT             shift and go to state 155


state 117

    (43) factor -> LPARENT arithmetic . RPARENT
    (38) arithmetic -> arithmetic . adding_operator term
    (75) adding_operator -> . PLUS
    (76) adding_operator -> . MINUS

    RPARENT         shift and go to state 156
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91

    adding_operator                shift and go to state 118

state 118

    (38) arithmetic -> arithmetic adding_operator . term
    (39) term -> . factor
    (40) term -> . term multiplying_operator factor
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    term                           shift and go to state 157
    factor                         shift and go to state 89

state 119

    (40) term -> term multiplying_operator . factor
    (41) factor -> . INT
    (42) factor -> . ID
    (43) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 80
    ID              shift and go to state 92
    LPARENT         shift and go to state 79

    factor                         shift and go to state 158

state 120

    (77) multiplying_operator -> TIMES .

    INT             reduce using rule 77 (multiplying_operator -> TIMES .)
    ID              reduce using rule 77 (multiplying_operator -> TIMES .)
    LPARENT         reduce using rule 77 (multiplying_operator -> TIMES .)


state 121

    (78) multiplying_operator -> EXP .

    INT             reduce using rule 78 (multiplying_operator -> EXP .)
    ID              reduce using rule 78 (multiplying_operator -> EXP .)
    LPARENT         reduce using rule 78 (multiplying_operator -> EXP .)


state 122

    (79) multiplying_operator -> DIVIDE .

    INT             reduce using rule 79 (multiplying_operator -> DIVIDE .)
    ID              reduce using rule 79 (multiplying_operator -> DIVIDE .)
    LPARENT         reduce using rule 79 (multiplying_operator -> DIVIDE .)


state 123

    (80) multiplying_operator -> DIVENT .

    INT             reduce using rule 80 (multiplying_operator -> DIVENT .)
    ID              reduce using rule 80 (multiplying_operator -> DIVENT .)
    LPARENT         reduce using rule 80 (multiplying_operator -> DIVENT .)


state 124

    (81) multiplying_operator -> MOD .

    INT             reduce using rule 81 (multiplying_operator -> MOD .)
    ID              reduce using rule 81 (multiplying_operator -> MOD .)
    LPARENT         reduce using rule 81 (multiplying_operator -> MOD .)


state 125

    (37) arithmetic -> adding_operator term .
    (40) term -> term . multiplying_operator factor
    (77) multiplying_operator -> . TIMES
    (78) multiplying_operator -> . EXP
    (79) multiplying_operator -> . DIVIDE
    (80) multiplying_operator -> . DIVENT
    (81) multiplying_operator -> . MOD

    PLUS            reduce using rule 37 (arithmetic -> adding_operator term .)
    MINUS           reduce using rule 37 (arithmetic -> adding_operator term .)
    SEMICOLON       reduce using rule 37 (arithmetic -> adding_operator term .)
    RPARENT         reduce using rule 37 (arithmetic -> adding_operator term .)
    TIMES           shift and go to state 120
    EXP             shift and go to state 121
    DIVIDE          shift and go to state 122
    DIVENT          shift and go to state 123
    MOD             shift and go to state 124

    multiplying_operator           shift and go to state 119

state 126

    (57) list -> PARENTCL list_term . PARENTCR

    PARENTCR        shift and go to state 159


state 127

    (58) list -> PARENTCL empty . PARENTCR

    PARENTCR        shift and go to state 160


state 128

    (59) list_term -> list_value . COMMA list_term
    (60) list_term -> list_value .

    COMMA           shift and go to state 161
    PARENTCR        reduce using rule 60 (list_term -> list_value .)


state 129

    (61) list_value -> value .

    COMMA           reduce using rule 61 (list_value -> value .)
    PARENTCR        reduce using rule 61 (list_value -> value .)


state 130

    (62) list_value -> list .

    COMMA           reduce using rule 62 (list_value -> list .)
    PARENTCR        reduce using rule 62 (list_value -> list .)


state 131

    (8) assignment -> GLOBAL ID ASSIGN a_content . SEMICOLON block

    SEMICOLON       shift and go to state 162


state 132

    (9) assignment -> ID COMMA ID ASSIGN . value COMMA value SEMICOLON block
    (82) value -> . FALSE
    (83) value -> . TRUE

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 163

state 133

    (22) insert -> ID DOT INSERT LPARENT . INT COMMA value RPARENT SEMICOLON block

    INT             shift and go to state 164


state 134

    (23) del -> ID DOT DELETE LPARENT . INT RPARENT SEMICOLON block

    INT             shift and go to state 165


state 135

    (31) shape -> ID DOT shape_arg SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 166
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 136

    (66) mat_consult -> ID PARENTCL indice COMMA . indice PARENTCR
    (68) indice -> . INT
    (69) indice -> . ID

    INT             shift and go to state 103
    ID              shift and go to state 100

    indice                         shift and go to state 167

state 137

    (92) complex_id -> ID PARENTCL indice PARENTCR .

    ASSIGN          reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)
    SEMICOLON       reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)
    DOT             reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)
    COMMA           reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)
    STEP            reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)
    LCORCH          reduce using rule 92 (complex_id -> ID PARENTCL indice PARENTCR .)


state 138

    (93) complex_id -> ID PARENTCL indice TP . indice PARENTCR
    (68) indice -> . INT
    (69) indice -> . ID

    INT             shift and go to state 103
    ID              shift and go to state 100

    indice                         shift and go to state 168

state 139

    (67) mat_consult -> ID PARENTCL TP COMMA . indice PARENTCR
    (68) indice -> . INT
    (69) indice -> . ID

    INT             shift and go to state 103
    ID              shift and go to state 100

    indice                         shift and go to state 169

state 140

    (20) type -> TYPE LPARENT ID RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 170


state 141

    (24) len -> LEN LPARENT ID RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 171


state 142

    (27) blink -> BLINK LPARENT b_content RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 172


state 143

    (51) b_content -> complex_id COMMA . INT COMMA time_mes COMMA value
    (52) b_content -> complex_id COMMA . value
    (82) value -> . FALSE
    (83) value -> . TRUE

    INT             shift and go to state 173
    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 174

state 144

    (92) complex_id -> ID PARENTCL . indice PARENTCR
    (93) complex_id -> ID PARENTCL . indice TP indice PARENTCR
    (68) indice -> . INT
    (69) indice -> . ID

    INT             shift and go to state 103
    ID              shift and go to state 100

    indice                         shift and go to state 175

state 145

    (28) delay -> DELAY LPARENT d_content RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 176


state 146

    (54) d_content -> INT COMMA . time_mes
    (72) time_mes -> . QUOTES MIL QUOTES
    (73) time_mes -> . QUOTES MIN QUOTES
    (74) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 177

state 147

    (90) identifier -> ID .
    (92) complex_id -> ID . PARENTCL indice PARENTCR
    (93) complex_id -> ID . PARENTCL indice TP indice PARENTCR

    STEP            reduce using rule 90 (identifier -> ID .)
    LCORCH          reduce using rule 90 (identifier -> ID .)
    PARENTCL        shift and go to state 144


state 148

    (33) for -> FOR ID IN iterable . step LCORCH block RCORCH SEMICOLON block
    (34) step -> . STEP INT
    (35) step -> . empty
    (96) empty -> .

    STEP            shift and go to state 179
    LCORCH          reduce using rule 96 (empty -> .)

    step                           shift and go to state 178
    empty                          shift and go to state 180

state 149

    (94) iterable -> identifier .

    STEP            reduce using rule 94 (iterable -> identifier .)
    LCORCH          reduce using rule 94 (iterable -> identifier .)


state 150

    (95) iterable -> INT .

    STEP            reduce using rule 95 (iterable -> INT .)
    LCORCH          reduce using rule 95 (iterable -> INT .)


state 151

    (91) identifier -> complex_id .

    STEP            reduce using rule 91 (identifier -> complex_id .)
    LCORCH          reduce using rule 91 (identifier -> complex_id .)


state 152

    (25) neg -> consult DOT NEG SEMICOLON block .

    $end            reduce using rule 25 (neg -> consult DOT NEG SEMICOLON block .)
    RCORCH          reduce using rule 25 (neg -> consult DOT NEG SEMICOLON block .)


state 153

    (26) t_f -> consult DOT tf SEMICOLON block .

    $end            reduce using rule 26 (t_f -> consult DOT tf SEMICOLON block .)
    RCORCH          reduce using rule 26 (t_f -> consult DOT tf SEMICOLON block .)


state 154

    (7) assignment -> identifier ASSIGN a_content SEMICOLON block .

    $end            reduce using rule 7 (assignment -> identifier ASSIGN a_content SEMICOLON block .)
    RCORCH          reduce using rule 7 (assignment -> identifier ASSIGN a_content SEMICOLON block .)


state 155

    (21) a_content -> RANGE LPARENT INT . COMMA value RPARENT

    COMMA           shift and go to state 181


state 156

    (43) factor -> LPARENT arithmetic RPARENT .

    TIMES           reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    EXP             reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    DIVIDE          reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    DIVENT          reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    MOD             reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    PLUS            reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    MINUS           reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    SEMICOLON       reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)
    RPARENT         reduce using rule 43 (factor -> LPARENT arithmetic RPARENT .)


state 157

    (38) arithmetic -> arithmetic adding_operator term .
    (40) term -> term . multiplying_operator factor
    (77) multiplying_operator -> . TIMES
    (78) multiplying_operator -> . EXP
    (79) multiplying_operator -> . DIVIDE
    (80) multiplying_operator -> . DIVENT
    (81) multiplying_operator -> . MOD

    PLUS            reduce using rule 38 (arithmetic -> arithmetic adding_operator term .)
    MINUS           reduce using rule 38 (arithmetic -> arithmetic adding_operator term .)
    SEMICOLON       reduce using rule 38 (arithmetic -> arithmetic adding_operator term .)
    RPARENT         reduce using rule 38 (arithmetic -> arithmetic adding_operator term .)
    TIMES           shift and go to state 120
    EXP             shift and go to state 121
    DIVIDE          shift and go to state 122
    DIVENT          shift and go to state 123
    MOD             shift and go to state 124

    multiplying_operator           shift and go to state 119

state 158

    (40) term -> term multiplying_operator factor .

    TIMES           reduce using rule 40 (term -> term multiplying_operator factor .)
    EXP             reduce using rule 40 (term -> term multiplying_operator factor .)
    DIVIDE          reduce using rule 40 (term -> term multiplying_operator factor .)
    DIVENT          reduce using rule 40 (term -> term multiplying_operator factor .)
    MOD             reduce using rule 40 (term -> term multiplying_operator factor .)
    PLUS            reduce using rule 40 (term -> term multiplying_operator factor .)
    MINUS           reduce using rule 40 (term -> term multiplying_operator factor .)
    SEMICOLON       reduce using rule 40 (term -> term multiplying_operator factor .)
    RPARENT         reduce using rule 40 (term -> term multiplying_operator factor .)


state 159

    (57) list -> PARENTCL list_term PARENTCR .

    SEMICOLON       reduce using rule 57 (list -> PARENTCL list_term PARENTCR .)
    COMMA           reduce using rule 57 (list -> PARENTCL list_term PARENTCR .)
    PARENTCR        reduce using rule 57 (list -> PARENTCL list_term PARENTCR .)


state 160

    (58) list -> PARENTCL empty PARENTCR .

    SEMICOLON       reduce using rule 58 (list -> PARENTCL empty PARENTCR .)
    COMMA           reduce using rule 58 (list -> PARENTCL empty PARENTCR .)
    PARENTCR        reduce using rule 58 (list -> PARENTCL empty PARENTCR .)


state 161

    (59) list_term -> list_value COMMA . list_term
    (59) list_term -> . list_value COMMA list_term
    (60) list_term -> . list_value
    (61) list_value -> . value
    (62) list_value -> . list
    (82) value -> . FALSE
    (83) value -> . TRUE
    (57) list -> . PARENTCL list_term PARENTCR
    (58) list -> . PARENTCL empty PARENTCR

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85
    PARENTCL        shift and go to state 88

    list_value                     shift and go to state 128
    list_term                      shift and go to state 182
    value                          shift and go to state 129
    list                           shift and go to state 130

state 162

    (8) assignment -> GLOBAL ID ASSIGN a_content SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 183
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 163

    (9) assignment -> ID COMMA ID ASSIGN value . COMMA value SEMICOLON block

    COMMA           shift and go to state 184


state 164

    (22) insert -> ID DOT INSERT LPARENT INT . COMMA value RPARENT SEMICOLON block

    COMMA           shift and go to state 185


state 165

    (23) del -> ID DOT DELETE LPARENT INT . RPARENT SEMICOLON block

    RPARENT         shift and go to state 186


state 166

    (31) shape -> ID DOT shape_arg SEMICOLON block .

    $end            reduce using rule 31 (shape -> ID DOT shape_arg SEMICOLON block .)
    RCORCH          reduce using rule 31 (shape -> ID DOT shape_arg SEMICOLON block .)


state 167

    (66) mat_consult -> ID PARENTCL indice COMMA indice . PARENTCR

    PARENTCR        shift and go to state 187


state 168

    (93) complex_id -> ID PARENTCL indice TP indice . PARENTCR

    PARENTCR        shift and go to state 188


state 169

    (67) mat_consult -> ID PARENTCL TP COMMA indice . PARENTCR

    PARENTCR        shift and go to state 189


state 170

    (20) type -> TYPE LPARENT ID RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 190
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 171

    (24) len -> LEN LPARENT ID RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 191
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 172

    (27) blink -> BLINK LPARENT b_content RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 192
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 173

    (51) b_content -> complex_id COMMA INT . COMMA time_mes COMMA value

    COMMA           shift and go to state 193


state 174

    (52) b_content -> complex_id COMMA value .

    RPARENT         reduce using rule 52 (b_content -> complex_id COMMA value .)


state 175

    (92) complex_id -> ID PARENTCL indice . PARENTCR
    (93) complex_id -> ID PARENTCL indice . TP indice PARENTCR

    PARENTCR        shift and go to state 137
    TP              shift and go to state 138


state 176

    (28) delay -> DELAY LPARENT d_content RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 194
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 177

    (54) d_content -> INT COMMA time_mes .

    RPARENT         reduce using rule 54 (d_content -> INT COMMA time_mes .)


state 178

    (33) for -> FOR ID IN iterable step . LCORCH block RCORCH SEMICOLON block

    LCORCH          shift and go to state 195


state 179

    (34) step -> STEP . INT

    INT             shift and go to state 196


state 180

    (35) step -> empty .

    LCORCH          reduce using rule 35 (step -> empty .)


state 181

    (21) a_content -> RANGE LPARENT INT COMMA . value RPARENT
    (82) value -> . FALSE
    (83) value -> . TRUE

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 197

state 182

    (59) list_term -> list_value COMMA list_term .

    PARENTCR        reduce using rule 59 (list_term -> list_value COMMA list_term .)


state 183

    (8) assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .

    $end            reduce using rule 8 (assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .)
    RCORCH          reduce using rule 8 (assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .)


state 184

    (9) assignment -> ID COMMA ID ASSIGN value COMMA . value SEMICOLON block
    (82) value -> . FALSE
    (83) value -> . TRUE

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 198

state 185

    (22) insert -> ID DOT INSERT LPARENT INT COMMA . value RPARENT SEMICOLON block
    (82) value -> . FALSE
    (83) value -> . TRUE

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 199

state 186

    (23) del -> ID DOT DELETE LPARENT INT RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 200


state 187

    (66) mat_consult -> ID PARENTCL indice COMMA indice PARENTCR .

    SEMICOLON       reduce using rule 66 (mat_consult -> ID PARENTCL indice COMMA indice PARENTCR .)
    DOT             reduce using rule 66 (mat_consult -> ID PARENTCL indice COMMA indice PARENTCR .)


state 188

    (93) complex_id -> ID PARENTCL indice TP indice PARENTCR .

    ASSIGN          reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)
    SEMICOLON       reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)
    DOT             reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)
    COMMA           reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)
    STEP            reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)
    LCORCH          reduce using rule 93 (complex_id -> ID PARENTCL indice TP indice PARENTCR .)


state 189

    (67) mat_consult -> ID PARENTCL TP COMMA indice PARENTCR .

    SEMICOLON       reduce using rule 67 (mat_consult -> ID PARENTCL TP COMMA indice PARENTCR .)
    DOT             reduce using rule 67 (mat_consult -> ID PARENTCL TP COMMA indice PARENTCR .)


state 190

    (20) type -> TYPE LPARENT ID RPARENT SEMICOLON block .

    $end            reduce using rule 20 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 20 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)


state 191

    (24) len -> LEN LPARENT ID RPARENT SEMICOLON block .

    $end            reduce using rule 24 (len -> LEN LPARENT ID RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 24 (len -> LEN LPARENT ID RPARENT SEMICOLON block .)


state 192

    (27) blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .

    $end            reduce using rule 27 (blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 27 (blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .)


state 193

    (51) b_content -> complex_id COMMA INT COMMA . time_mes COMMA value
    (72) time_mes -> . QUOTES MIL QUOTES
    (73) time_mes -> . QUOTES MIN QUOTES
    (74) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 201

state 194

    (28) delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .

    $end            reduce using rule 28 (delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 28 (delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .)


state 195

    (33) for -> FOR ID IN iterable step LCORCH . block RCORCH SEMICOLON block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 202
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 196

    (34) step -> STEP INT .

    LCORCH          reduce using rule 34 (step -> STEP INT .)


state 197

    (21) a_content -> RANGE LPARENT INT COMMA value . RPARENT

    RPARENT         shift and go to state 203


state 198

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value . SEMICOLON block

    SEMICOLON       shift and go to state 204


state 199

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value . RPARENT SEMICOLON block

    RPARENT         shift and go to state 205


state 200

    (23) del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 206
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 201

    (51) b_content -> complex_id COMMA INT COMMA time_mes . COMMA value

    COMMA           shift and go to state 207


state 202

    (33) for -> FOR ID IN iterable step LCORCH block . RCORCH SEMICOLON block

    RCORCH          shift and go to state 208


state 203

    (21) a_content -> RANGE LPARENT INT COMMA value RPARENT .

    SEMICOLON       reduce using rule 21 (a_content -> RANGE LPARENT INT COMMA value RPARENT .)


state 204

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 209
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 205

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 210


state 206

    (23) del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .

    $end            reduce using rule 23 (del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 23 (del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .)


state 207

    (51) b_content -> complex_id COMMA INT COMMA time_mes COMMA . value
    (82) value -> . FALSE
    (83) value -> . TRUE

    FALSE           shift and go to state 84
    TRUE            shift and go to state 85

    value                          shift and go to state 211

state 208

    (33) for -> FOR ID IN iterable step LCORCH block RCORCH . SEMICOLON block

    SEMICOLON       shift and go to state 212


state 209

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .

    $end            reduce using rule 9 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)
    RCORCH          reduce using rule 9 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)


state 210

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 213
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 211

    (51) b_content -> complex_id COMMA INT COMMA time_mes COMMA value .

    RPARENT         reduce using rule 51 (b_content -> complex_id COMMA INT COMMA time_mes COMMA value .)


state 212

    (33) for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult SEMICOLON block
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t_f
    (17) function -> . blink
    (18) function -> . delay
    (19) function -> . shape
    (63) consult -> . list_consult
    (64) consult -> . mat_consult
    (32) cycle -> . for
    (90) identifier -> . ID
    (91) identifier -> . complex_id
    (96) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . consult DOT NEG SEMICOLON block
    (26) t_f -> . consult DOT tf SEMICOLON block
    (27) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (28) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) shape -> . ID DOT shape_arg SEMICOLON block
    (65) list_consult -> . complex_id
    (66) mat_consult -> . ID PARENTCL indice COMMA indice PARENTCR
    (67) mat_consult -> . ID PARENTCL TP COMMA indice PARENTCR
    (33) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (92) complex_id -> . ID PARENTCL indice PARENTCR
    (93) complex_id -> . ID PARENTCL indice TP indice PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 96 (empty -> .)
    RCORCH          reduce using rule 96 (empty -> .)
    TYPE            shift and go to state 55
    LEN             shift and go to state 56
    BLINK           shift and go to state 57
    DELAY           shift and go to state 58
    FOR             shift and go to state 59

    block                          shift and go to state 214
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t_f                            shift and go to state 47
    blink                          shift and go to state 48
    delay                          shift and go to state 49
    shape                          shift and go to state 50
    list_consult                   shift and go to state 51
    mat_consult                    shift and go to state 52
    for                            shift and go to state 53
    complex_id                     shift and go to state 54

state 213

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .

    $end            reduce using rule 22 (insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 22 (insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .)


state 214

    (33) for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .

    $end            reduce using rule 33 (for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .)
    RCORCH          reduce using rule 33 (for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .)

