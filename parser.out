Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLINK
    BOOKED
    CONST
    DELETE
    DIVENT
    DIVIDE
    DOT
    ELSE
    EXP
    F
    FOR
    GLOBAL
    GT
    GTE
    IF
    INSERT
    LCORCH
    LEN
    LENGHTERROR
    LT
    LTE
    MINUS
    MOD
    NE
    NEG
    PARENTCL
    PARENTCR
    PLUS
    PROCEDURE
    RANGE
    RCORCH
    T
    TIMES
    TP
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     statement -> assignment function
Rule 3     assignment -> simpleAssignment doubleAssignment
Rule 4     simpleAssignment -> ID ASSIGN term SEMICOLON statement
Rule 5     simpleAssignment -> empty
Rule 6     doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
Rule 7     doubleAssignment -> empty
Rule 8     function -> type
Rule 9     function -> empty
Rule 10    type -> TYPE LPARENT ID RPARENT SEMICOLON statement
Rule 11    term -> FALSE
Rule 12    term -> TRUE
Rule 13    term -> factor
Rule 14    factor -> ID
Rule 15    factor -> INT
Rule 16    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 4 6
BLINK                : 
BOOKED               : 
COMMA                : 6 6
CONST                : 
DELETE               : 
DIVENT               : 
DIVIDE               : 
DOT                  : 
ELSE                 : 
EXP                  : 
F                    : 
FALSE                : 11
FOR                  : 
GLOBAL               : 
GT                   : 
GTE                  : 
ID                   : 4 6 6 10 14
IF                   : 
INSERT               : 
INT                  : 15
LCORCH               : 
LEN                  : 
LENGHTERROR          : 
LPARENT              : 10
LT                   : 
LTE                  : 
MINUS                : 
MOD                  : 
NE                   : 
NEG                  : 
PARENTCL             : 
PARENTCR             : 
PLUS                 : 
PROCEDURE            : 
RANGE                : 
RCORCH               : 
RPARENT              : 10
SEMICOLON            : 4 6 10
T                    : 
TIMES                : 
TP                   : 
TRUE                 : 12
TYPE                 : 10
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

assignment           : 2
doubleAssignment     : 3
empty                : 5 7 9
factor               : 13
function             : 2
program              : 0
simpleAssignment     : 3
statement            : 1 4 6 10
term                 : 4 6 6
type                 : 8

Parsing method: SLR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) statement -> . assignment function
    (3) assignment -> . simpleAssignment doubleAssignment
    (4) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (5) simpleAssignment -> . empty
    (16) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 5
    TYPE            reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! ID              [ reduce using rule 16 (empty -> .) ]

    program                        shift and go to state 1
    statement                      shift and go to state 2
    assignment                     shift and go to state 3
    simpleAssignment               shift and go to state 4
    empty                          shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) statement -> assignment . function
    (8) function -> . type
    (9) function -> . empty
    (10) type -> . TYPE LPARENT ID RPARENT SEMICOLON statement
    (16) empty -> .

  ! shift/reduce conflict for TYPE resolved as shift
    TYPE            shift and go to state 10
    ID              reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! TYPE            [ reduce using rule 16 (empty -> .) ]

    function                       shift and go to state 7
    type                           shift and go to state 8
    empty                          shift and go to state 9

state 4

    (3) assignment -> simpleAssignment . doubleAssignment
    (6) doubleAssignment -> . ID COMMA ID ASSIGN term COMMA term SEMICOLON statement
    (7) doubleAssignment -> . empty
    (16) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 12
    TYPE            reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! ID              [ reduce using rule 16 (empty -> .) ]

    doubleAssignment               shift and go to state 11
    empty                          shift and go to state 13

state 5

    (4) simpleAssignment -> ID . ASSIGN term SEMICOLON statement

    ASSIGN          shift and go to state 14


state 6

    (5) simpleAssignment -> empty .

    ID              reduce using rule 5 (simpleAssignment -> empty .)
    TYPE            reduce using rule 5 (simpleAssignment -> empty .)
    $end            reduce using rule 5 (simpleAssignment -> empty .)


state 7

    (2) statement -> assignment function .

    $end            reduce using rule 2 (statement -> assignment function .)
    ID              reduce using rule 2 (statement -> assignment function .)
    TYPE            reduce using rule 2 (statement -> assignment function .)


state 8

    (8) function -> type .

    $end            reduce using rule 8 (function -> type .)
    ID              reduce using rule 8 (function -> type .)
    TYPE            reduce using rule 8 (function -> type .)


state 9

    (9) function -> empty .

    $end            reduce using rule 9 (function -> empty .)
    ID              reduce using rule 9 (function -> empty .)
    TYPE            reduce using rule 9 (function -> empty .)


state 10

    (10) type -> TYPE . LPARENT ID RPARENT SEMICOLON statement

    LPARENT         shift and go to state 15


state 11

    (3) assignment -> simpleAssignment doubleAssignment .

    TYPE            reduce using rule 3 (assignment -> simpleAssignment doubleAssignment .)
    $end            reduce using rule 3 (assignment -> simpleAssignment doubleAssignment .)
    ID              reduce using rule 3 (assignment -> simpleAssignment doubleAssignment .)


state 12

    (6) doubleAssignment -> ID . COMMA ID ASSIGN term COMMA term SEMICOLON statement

    COMMA           shift and go to state 16


state 13

    (7) doubleAssignment -> empty .

    TYPE            reduce using rule 7 (doubleAssignment -> empty .)
    $end            reduce using rule 7 (doubleAssignment -> empty .)
    ID              reduce using rule 7 (doubleAssignment -> empty .)


state 14

    (4) simpleAssignment -> ID ASSIGN . term SEMICOLON statement
    (11) term -> . FALSE
    (12) term -> . TRUE
    (13) term -> . factor
    (14) factor -> . ID
    (15) factor -> . INT

    FALSE           shift and go to state 19
    TRUE            shift and go to state 20
    ID              shift and go to state 17
    INT             shift and go to state 22

    term                           shift and go to state 18
    factor                         shift and go to state 21

state 15

    (10) type -> TYPE LPARENT . ID RPARENT SEMICOLON statement

    ID              shift and go to state 23


state 16

    (6) doubleAssignment -> ID COMMA . ID ASSIGN term COMMA term SEMICOLON statement

    ID              shift and go to state 24


state 17

    (14) factor -> ID .

    SEMICOLON       reduce using rule 14 (factor -> ID .)
    COMMA           reduce using rule 14 (factor -> ID .)


state 18

    (4) simpleAssignment -> ID ASSIGN term . SEMICOLON statement

    SEMICOLON       shift and go to state 25


state 19

    (11) term -> FALSE .

    SEMICOLON       reduce using rule 11 (term -> FALSE .)
    COMMA           reduce using rule 11 (term -> FALSE .)


state 20

    (12) term -> TRUE .

    SEMICOLON       reduce using rule 12 (term -> TRUE .)
    COMMA           reduce using rule 12 (term -> TRUE .)


state 21

    (13) term -> factor .

    SEMICOLON       reduce using rule 13 (term -> factor .)
    COMMA           reduce using rule 13 (term -> factor .)


state 22

    (15) factor -> INT .

    SEMICOLON       reduce using rule 15 (factor -> INT .)
    COMMA           reduce using rule 15 (factor -> INT .)


state 23

    (10) type -> TYPE LPARENT ID . RPARENT SEMICOLON statement

    RPARENT         shift and go to state 26


state 24

    (6) doubleAssignment -> ID COMMA ID . ASSIGN term COMMA term SEMICOLON statement

    ASSIGN          shift and go to state 27


state 25

    (4) simpleAssignment -> ID ASSIGN term SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . simpleAssignment doubleAssignment
    (4) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (5) simpleAssignment -> . empty
    (16) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 5
    TYPE            reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! ID              [ reduce using rule 16 (empty -> .) ]

    statement                      shift and go to state 28
    assignment                     shift and go to state 3
    simpleAssignment               shift and go to state 4
    empty                          shift and go to state 6

state 26

    (10) type -> TYPE LPARENT ID RPARENT . SEMICOLON statement

    SEMICOLON       shift and go to state 29


state 27

    (6) doubleAssignment -> ID COMMA ID ASSIGN . term COMMA term SEMICOLON statement
    (11) term -> . FALSE
    (12) term -> . TRUE
    (13) term -> . factor
    (14) factor -> . ID
    (15) factor -> . INT

    FALSE           shift and go to state 19
    TRUE            shift and go to state 20
    ID              shift and go to state 17
    INT             shift and go to state 22

    term                           shift and go to state 30
    factor                         shift and go to state 21

state 28

    (4) simpleAssignment -> ID ASSIGN term SEMICOLON statement .

    ID              reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON statement .)
    TYPE            reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON statement .)
    $end            reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON statement .)


state 29

    (10) type -> TYPE LPARENT ID RPARENT SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . simpleAssignment doubleAssignment
    (4) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (5) simpleAssignment -> . empty
    (16) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 5
    TYPE            reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! ID              [ reduce using rule 16 (empty -> .) ]

    statement                      shift and go to state 31
    assignment                     shift and go to state 3
    simpleAssignment               shift and go to state 4
    empty                          shift and go to state 6

state 30

    (6) doubleAssignment -> ID COMMA ID ASSIGN term . COMMA term SEMICOLON statement

    COMMA           shift and go to state 32


state 31

    (10) type -> TYPE LPARENT ID RPARENT SEMICOLON statement .

    $end            reduce using rule 10 (type -> TYPE LPARENT ID RPARENT SEMICOLON statement .)
    ID              reduce using rule 10 (type -> TYPE LPARENT ID RPARENT SEMICOLON statement .)
    TYPE            reduce using rule 10 (type -> TYPE LPARENT ID RPARENT SEMICOLON statement .)


state 32

    (6) doubleAssignment -> ID COMMA ID ASSIGN term COMMA . term SEMICOLON statement
    (11) term -> . FALSE
    (12) term -> . TRUE
    (13) term -> . factor
    (14) factor -> . ID
    (15) factor -> . INT

    FALSE           shift and go to state 19
    TRUE            shift and go to state 20
    ID              shift and go to state 17
    INT             shift and go to state 22

    term                           shift and go to state 33
    factor                         shift and go to state 21

state 33

    (6) doubleAssignment -> ID COMMA ID ASSIGN term COMMA term . SEMICOLON statement

    SEMICOLON       shift and go to state 34


state 34

    (6) doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON . statement
    (2) statement -> . assignment function
    (3) assignment -> . simpleAssignment doubleAssignment
    (4) simpleAssignment -> . ID ASSIGN term SEMICOLON statement
    (5) simpleAssignment -> . empty
    (16) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 5
    TYPE            reduce using rule 16 (empty -> .)
    $end            reduce using rule 16 (empty -> .)

  ! ID              [ reduce using rule 16 (empty -> .) ]

    statement                      shift and go to state 35
    assignment                     shift and go to state 3
    simpleAssignment               shift and go to state 4
    empty                          shift and go to state 6

state 35

    (6) doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .

    TYPE            reduce using rule 6 (doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .)
    $end            reduce using rule 6 (doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .)
    ID              reduce using rule 6 (doubleAssignment -> ID COMMA ID ASSIGN term COMMA term SEMICOLON statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for ID in state 34 resolved as shift
