Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLINK
    BOOKED
    COMMA
    CONST
    DELETE
    DIVENT
    DIVIDE
    DOT
    ELSE
    EXP
    F
    FOR
    GLOBAL
    GT
    GTE
    IF
    INSERT
    LCORCH
    LEN
    LENGHTERROR
    LT
    LTE
    MINUS
    MOD
    NE
    NEG
    PARENTCL
    PARENTCR
    PLUS
    PROCEDURE
    RANGE
    RCORCH
    T
    TIMES
    TP
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> simpleAssignment function
Rule 3     simpleAssignment -> simpleAssignment ID ASSIGN term SEMICOLON
Rule 4     simpleAssignment -> ID ASSIGN term SEMICOLON
Rule 5     simpleAssignment -> empty
Rule 6     function -> type
Rule 7     function -> empty
Rule 8     type -> TYPE LPARENT ID RPARENT SEMICOLON
Rule 9     term -> TRUE
Rule 10    term -> FALSE
Rule 11    term -> factor
Rule 12    factor -> ID
Rule 13    factor -> INT
Rule 14    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 3 4
BLINK                : 
BOOKED               : 
COMMA                : 
CONST                : 
DELETE               : 
DIVENT               : 
DIVIDE               : 
DOT                  : 
ELSE                 : 
EXP                  : 
F                    : 
FALSE                : 10
FOR                  : 
GLOBAL               : 
GT                   : 
GTE                  : 
ID                   : 3 4 8 12
IF                   : 
INSERT               : 
INT                  : 13
LCORCH               : 
LEN                  : 
LENGHTERROR          : 
LPARENT              : 8
LT                   : 
LTE                  : 
MINUS                : 
MOD                  : 
NE                   : 
NEG                  : 
PARENTCL             : 
PARENTCR             : 
PLUS                 : 
PROCEDURE            : 
RANGE                : 
RCORCH               : 
RPARENT              : 8
SEMICOLON            : 3 4 8
T                    : 
TIMES                : 
TP                   : 
TRUE                 : 9
TYPE                 : 8
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

block                : 1
empty                : 5 7
factor               : 11
function             : 2
program              : 0
simpleAssignment     : 2 3
term                 : 3 4
type                 : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . simpleAssignment function
    (3) simpleAssignment -> . simpleAssignment ID ASSIGN term SEMICOLON
    (4) simpleAssignment -> . ID ASSIGN term SEMICOLON
    (5) simpleAssignment -> . empty
    (14) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 4
    TYPE            reduce using rule 14 (empty -> .)
    $end            reduce using rule 14 (empty -> .)

  ! ID              [ reduce using rule 14 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    simpleAssignment               shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> simpleAssignment . function
    (3) simpleAssignment -> simpleAssignment . ID ASSIGN term SEMICOLON
    (6) function -> . type
    (7) function -> . empty
    (8) type -> . TYPE LPARENT ID RPARENT SEMICOLON
    (14) empty -> .

    ID              shift and go to state 7
    TYPE            shift and go to state 10
    $end            reduce using rule 14 (empty -> .)

    function                       shift and go to state 6
    type                           shift and go to state 8
    empty                          shift and go to state 9

state 4

    (4) simpleAssignment -> ID . ASSIGN term SEMICOLON

    ASSIGN          shift and go to state 11


state 5

    (5) simpleAssignment -> empty .

    ID              reduce using rule 5 (simpleAssignment -> empty .)
    TYPE            reduce using rule 5 (simpleAssignment -> empty .)
    $end            reduce using rule 5 (simpleAssignment -> empty .)


state 6

    (2) block -> simpleAssignment function .

    $end            reduce using rule 2 (block -> simpleAssignment function .)


state 7

    (3) simpleAssignment -> simpleAssignment ID . ASSIGN term SEMICOLON

    ASSIGN          shift and go to state 12


state 8

    (6) function -> type .

    $end            reduce using rule 6 (function -> type .)


state 9

    (7) function -> empty .

    $end            reduce using rule 7 (function -> empty .)


state 10

    (8) type -> TYPE . LPARENT ID RPARENT SEMICOLON

    LPARENT         shift and go to state 13


state 11

    (4) simpleAssignment -> ID ASSIGN . term SEMICOLON
    (9) term -> . TRUE
    (10) term -> . FALSE
    (11) term -> . factor
    (12) factor -> . ID
    (13) factor -> . INT

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    ID              shift and go to state 14
    INT             shift and go to state 19

    term                           shift and go to state 15
    factor                         shift and go to state 18

state 12

    (3) simpleAssignment -> simpleAssignment ID ASSIGN . term SEMICOLON
    (9) term -> . TRUE
    (10) term -> . FALSE
    (11) term -> . factor
    (12) factor -> . ID
    (13) factor -> . INT

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    ID              shift and go to state 14
    INT             shift and go to state 19

    term                           shift and go to state 20
    factor                         shift and go to state 18

state 13

    (8) type -> TYPE LPARENT . ID RPARENT SEMICOLON

    ID              shift and go to state 21


state 14

    (12) factor -> ID .

    SEMICOLON       reduce using rule 12 (factor -> ID .)


state 15

    (4) simpleAssignment -> ID ASSIGN term . SEMICOLON

    SEMICOLON       shift and go to state 22


state 16

    (9) term -> TRUE .

    SEMICOLON       reduce using rule 9 (term -> TRUE .)


state 17

    (10) term -> FALSE .

    SEMICOLON       reduce using rule 10 (term -> FALSE .)


state 18

    (11) term -> factor .

    SEMICOLON       reduce using rule 11 (term -> factor .)


state 19

    (13) factor -> INT .

    SEMICOLON       reduce using rule 13 (factor -> INT .)


state 20

    (3) simpleAssignment -> simpleAssignment ID ASSIGN term . SEMICOLON

    SEMICOLON       shift and go to state 23


state 21

    (8) type -> TYPE LPARENT ID . RPARENT SEMICOLON

    RPARENT         shift and go to state 24


state 22

    (4) simpleAssignment -> ID ASSIGN term SEMICOLON .

    ID              reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON .)
    TYPE            reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON .)
    $end            reduce using rule 4 (simpleAssignment -> ID ASSIGN term SEMICOLON .)


state 23

    (3) simpleAssignment -> simpleAssignment ID ASSIGN term SEMICOLON .

    ID              reduce using rule 3 (simpleAssignment -> simpleAssignment ID ASSIGN term SEMICOLON .)
    TYPE            reduce using rule 3 (simpleAssignment -> simpleAssignment ID ASSIGN term SEMICOLON .)
    $end            reduce using rule 3 (simpleAssignment -> simpleAssignment ID ASSIGN term SEMICOLON .)


state 24

    (8) type -> TYPE LPARENT ID RPARENT . SEMICOLON

    SEMICOLON       shift and go to state 25


state 25

    (8) type -> TYPE LPARENT ID RPARENT SEMICOLON .

    $end            reduce using rule 8 (type -> TYPE LPARENT ID RPARENT SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
