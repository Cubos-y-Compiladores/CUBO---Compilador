Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOKED
    CALL
    CONST
    ELSE
    IF
    LENGHTERROR
    MAIN
    PROCEDURE
    SHAPEA
    SHAPEC
    SHAPEF
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> const_block
Rule 2     const_block -> const const const const const block
Rule 3     block -> assignment
Rule 4     block -> function
Rule 5     block -> consult
Rule 6     block -> cycle
Rule 7     assignment -> identifier ASSIGN a_content SEMICOLON block
Rule 8     assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block
Rule 9     assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block
Rule 10    assignment -> empty
Rule 11    function -> type
Rule 12    function -> insert
Rule 13    function -> del
Rule 14    function -> len
Rule 15    function -> neg
Rule 16    function -> t
Rule 17    function -> f
Rule 18    function -> blink
Rule 19    function -> delay
Rule 20    type -> TYPE LPARENT ID RPARENT SEMICOLON block
Rule 21    a_content -> RANGE LPARENT INT COMMA value RPARENT
Rule 22    insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
Rule 23    del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
Rule 24    len -> LEN LPARENT ID RPARENT SEMICOLON block
Rule 25    neg -> complex_id DOT NEG SEMICOLON block
Rule 26    t -> complex_id DOT T SEMICOLON block
Rule 27    f -> complex_id DOT F SEMICOLON block
Rule 28    blink -> BLINK LPARENT b_content RPARENT SEMICOLON block
Rule 29    delay -> DELAY LPARENT d_content RPARENT SEMICOLON block
Rule 30    cycle -> for
Rule 31    for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
Rule 32    step -> STEP INT
Rule 33    step -> empty
Rule 34    arithmetic -> term
Rule 35    arithmetic -> adding_operator term
Rule 36    arithmetic -> arithmetic adding_operator term
Rule 37    term -> factor
Rule 38    term -> term multiplying_operator factor
Rule 39    factor -> INT
Rule 40    factor -> ID
Rule 41    factor -> LPARENT arithmetic RPARENT
Rule 42    const -> TIMER ASSIGN INT SEMICOLON
Rule 43    const -> RANGOTIMER ASSIGN time_mes SEMICOLON
Rule 44    const -> dimension ASSIGN INT SEMICOLON
Rule 45    const -> CUBO ASSIGN INT SEMICOLON
Rule 46    a_content -> value
Rule 47    a_content -> arithmetic
Rule 48    a_content -> PARENTCL list_term PARENTCR
Rule 49    b_content -> complex_id COMMA INT COMMA time_mes COMMA value
Rule 50    b_content -> complex_id COMMA value
Rule 51    d_content -> empty
Rule 52    d_content -> INT COMMA time_mes
Rule 53    list_term -> value COMMA list_term
Rule 54    list_term -> value
Rule 55    list_term -> <empty>
Rule 56    consult -> ID PARENTCL INT PARENTCR SEMICOLON block
Rule 57    consult -> ID PARENTCL INT TP INT PARENTCR SEMICOLON block
Rule 58    dimension -> DIMFILAS
Rule 59    dimension -> DIMCOLUMNAS
Rule 60    time_mes -> QUOTES MIL QUOTES
Rule 61    time_mes -> QUOTES MIN QUOTES
Rule 62    time_mes -> QUOTES SEG QUOTES
Rule 63    adding_operator -> PLUS
Rule 64    adding_operator -> MINUS
Rule 65    multiplying_operator -> TIMES
Rule 66    multiplying_operator -> EXP
Rule 67    multiplying_operator -> DIVIDE
Rule 68    multiplying_operator -> DIVENT
Rule 69    multiplying_operator -> MOD
Rule 70    value -> FALSE
Rule 71    value -> TRUE
Rule 72    relation -> ASSIGN
Rule 73    relation -> NE
Rule 74    relation -> LT
Rule 75    relation -> GT
Rule 76    relation -> LTE
Rule 77    relation -> GTE
Rule 78    identifier -> ID
Rule 79    identifier -> complex_id
Rule 80    complex_id -> ID PARENTCL INT PARENTCR
Rule 81    complex_id -> ID PARENTCL INT TP INT PARENTCR
Rule 82    complex_id -> ID PARENTCL ID PARENTCR
Rule 83    iterable -> identifier
Rule 84    iterable -> INT
Rule 85    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 7 8 9 42 43 44 45 72
BLINK                : 28
BOOKED               : 
CALL                 : 
COMMA                : 9 9 21 22 49 49 49 50 52 53
CONST                : 
CUBO                 : 45
DELAY                : 29
DELETE               : 23
DIMCOLUMNAS          : 59
DIMFILAS             : 58
DIVENT               : 68
DIVIDE               : 67
DOT                  : 22 23 25 26 27
ELSE                 : 
EXP                  : 66
F                    : 27
FALSE                : 70
FOR                  : 31
GLOBAL               : 8
GT                   : 75
GTE                  : 77
ID                   : 8 9 9 20 22 23 24 31 40 56 57 78 80 81 82 82
IF                   : 
IN                   : 31
INSERT               : 22
INT                  : 21 22 23 32 39 42 44 45 49 52 56 57 57 80 81 81 84
LCORCH               : 31
LEN                  : 24
LENGHTERROR          : 
LPARENT              : 20 21 22 23 24 28 29 41
LT                   : 74
LTE                  : 76
MAIN                 : 
MIL                  : 60
MIN                  : 61
MINUS                : 64
MOD                  : 69
NE                   : 73
NEG                  : 25
PARENTCL             : 48 56 57 80 81 82
PARENTCR             : 48 56 57 80 81 82
PLUS                 : 63
PROCEDURE            : 
QUOTES               : 60 60 61 61 62 62
RANGE                : 21
RANGOTIMER           : 43
RCORCH               : 31
RPARENT              : 20 21 22 23 24 28 29 41
SEG                  : 62
SEMICOLON            : 7 8 9 20 22 23 24 25 26 27 28 29 31 42 43 44 45 56 57
SHAPEA               : 
SHAPEC               : 
SHAPEF               : 
STEP                 : 32
T                    : 26
TIMER                : 42
TIMES                : 65
TP                   : 57 81
TRUE                 : 71
TYPE                 : 20
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

a_content            : 7 8
adding_operator      : 35 36
arithmetic           : 36 41 47
assignment           : 3
b_content            : 28
blink                : 18
block                : 2 7 8 9 20 22 23 24 25 26 27 28 29 31 31 56 57
complex_id           : 25 26 27 49 50 79
const                : 2 2 2 2 2
const_block          : 1
consult              : 5
cycle                : 6
d_content            : 29
del                  : 13
delay                : 19
dimension            : 44
empty                : 10 33 51
f                    : 17
factor               : 37 38
for                  : 30
function             : 4
identifier           : 7 83
insert               : 12
iterable             : 31
len                  : 14
list_term            : 48 53
multiplying_operator : 38
neg                  : 15
program              : 0
relation             : 
step                 : 31
t                    : 16
term                 : 34 35 36 38
time_mes             : 43 49 52
type                 : 11
value                : 9 9 21 22 46 49 50 53 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . const_block
    (2) const_block -> . const const const const const block
    (42) const -> . TIMER ASSIGN INT SEMICOLON
    (43) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (44) const -> . dimension ASSIGN INT SEMICOLON
    (45) const -> . CUBO ASSIGN INT SEMICOLON
    (58) dimension -> . DIMFILAS
    (59) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    program                        shift and go to state 1
    const_block                    shift and go to state 2
    const                          shift and go to state 3
    dimension                      shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> const_block .

    $end            reduce using rule 1 (program -> const_block .)


state 3

    (2) const_block -> const . const const const const block
    (42) const -> . TIMER ASSIGN INT SEMICOLON
    (43) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (44) const -> . dimension ASSIGN INT SEMICOLON
    (45) const -> . CUBO ASSIGN INT SEMICOLON
    (58) dimension -> . DIMFILAS
    (59) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 10
    dimension                      shift and go to state 6

state 4

    (42) const -> TIMER . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 11


state 5

    (43) const -> RANGOTIMER . ASSIGN time_mes SEMICOLON

    ASSIGN          shift and go to state 12


state 6

    (44) const -> dimension . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 13


state 7

    (45) const -> CUBO . ASSIGN INT SEMICOLON

    ASSIGN          shift and go to state 14


state 8

    (58) dimension -> DIMFILAS .

    ASSIGN          reduce using rule 58 (dimension -> DIMFILAS .)


state 9

    (59) dimension -> DIMCOLUMNAS .

    ASSIGN          reduce using rule 59 (dimension -> DIMCOLUMNAS .)


state 10

    (2) const_block -> const const . const const const block
    (42) const -> . TIMER ASSIGN INT SEMICOLON
    (43) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (44) const -> . dimension ASSIGN INT SEMICOLON
    (45) const -> . CUBO ASSIGN INT SEMICOLON
    (58) dimension -> . DIMFILAS
    (59) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 15
    dimension                      shift and go to state 6

state 11

    (42) const -> TIMER ASSIGN . INT SEMICOLON

    INT             shift and go to state 16


state 12

    (43) const -> RANGOTIMER ASSIGN . time_mes SEMICOLON
    (60) time_mes -> . QUOTES MIL QUOTES
    (61) time_mes -> . QUOTES MIN QUOTES
    (62) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 17

state 13

    (44) const -> dimension ASSIGN . INT SEMICOLON

    INT             shift and go to state 19


state 14

    (45) const -> CUBO ASSIGN . INT SEMICOLON

    INT             shift and go to state 20


state 15

    (2) const_block -> const const const . const const block
    (42) const -> . TIMER ASSIGN INT SEMICOLON
    (43) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (44) const -> . dimension ASSIGN INT SEMICOLON
    (45) const -> . CUBO ASSIGN INT SEMICOLON
    (58) dimension -> . DIMFILAS
    (59) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 21
    dimension                      shift and go to state 6

state 16

    (42) const -> TIMER ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 22


state 17

    (43) const -> RANGOTIMER ASSIGN time_mes . SEMICOLON

    SEMICOLON       shift and go to state 23


state 18

    (60) time_mes -> QUOTES . MIL QUOTES
    (61) time_mes -> QUOTES . MIN QUOTES
    (62) time_mes -> QUOTES . SEG QUOTES

    MIL             shift and go to state 24
    MIN             shift and go to state 25
    SEG             shift and go to state 26


state 19

    (44) const -> dimension ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 27


state 20

    (45) const -> CUBO ASSIGN INT . SEMICOLON

    SEMICOLON       shift and go to state 28


state 21

    (2) const_block -> const const const const . const block
    (42) const -> . TIMER ASSIGN INT SEMICOLON
    (43) const -> . RANGOTIMER ASSIGN time_mes SEMICOLON
    (44) const -> . dimension ASSIGN INT SEMICOLON
    (45) const -> . CUBO ASSIGN INT SEMICOLON
    (58) dimension -> . DIMFILAS
    (59) dimension -> . DIMCOLUMNAS

    TIMER           shift and go to state 4
    RANGOTIMER      shift and go to state 5
    CUBO            shift and go to state 7
    DIMFILAS        shift and go to state 8
    DIMCOLUMNAS     shift and go to state 9

    const                          shift and go to state 29
    dimension                      shift and go to state 6

state 22

    (42) const -> TIMER ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    ID              reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)
    $end            reduce using rule 42 (const -> TIMER ASSIGN INT SEMICOLON .)


state 23

    (43) const -> RANGOTIMER ASSIGN time_mes SEMICOLON .

    TIMER           reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    RANGOTIMER      reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    CUBO            reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DIMFILAS        reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    GLOBAL          reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    ID              reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    TYPE            reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    LEN             reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    BLINK           reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    DELAY           reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    FOR             reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)
    $end            reduce using rule 43 (const -> RANGOTIMER ASSIGN time_mes SEMICOLON .)


state 24

    (60) time_mes -> QUOTES MIL . QUOTES

    QUOTES          shift and go to state 30


state 25

    (61) time_mes -> QUOTES MIN . QUOTES

    QUOTES          shift and go to state 31


state 26

    (62) time_mes -> QUOTES SEG . QUOTES

    QUOTES          shift and go to state 32


state 27

    (44) const -> dimension ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    ID              reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)
    $end            reduce using rule 44 (const -> dimension ASSIGN INT SEMICOLON .)


state 28

    (45) const -> CUBO ASSIGN INT SEMICOLON .

    TIMER           reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    RANGOTIMER      reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    CUBO            reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    DIMFILAS        reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    DIMCOLUMNAS     reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    GLOBAL          reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    ID              reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    TYPE            reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    LEN             reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    BLINK           reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    DELAY           reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    FOR             reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)
    $end            reduce using rule 45 (const -> CUBO ASSIGN INT SEMICOLON .)


state 29

    (2) const_block -> const const const const const . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 33
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 30

    (60) time_mes -> QUOTES MIL QUOTES .

    SEMICOLON       reduce using rule 60 (time_mes -> QUOTES MIL QUOTES .)
    RPARENT         reduce using rule 60 (time_mes -> QUOTES MIL QUOTES .)
    COMMA           reduce using rule 60 (time_mes -> QUOTES MIL QUOTES .)


state 31

    (61) time_mes -> QUOTES MIN QUOTES .

    SEMICOLON       reduce using rule 61 (time_mes -> QUOTES MIN QUOTES .)
    RPARENT         reduce using rule 61 (time_mes -> QUOTES MIN QUOTES .)
    COMMA           reduce using rule 61 (time_mes -> QUOTES MIN QUOTES .)


state 32

    (62) time_mes -> QUOTES SEG QUOTES .

    SEMICOLON       reduce using rule 62 (time_mes -> QUOTES SEG QUOTES .)
    RPARENT         reduce using rule 62 (time_mes -> QUOTES SEG QUOTES .)
    COMMA           reduce using rule 62 (time_mes -> QUOTES SEG QUOTES .)


state 33

    (2) const_block -> const const const const const block .

    $end            reduce using rule 2 (const_block -> const const const const const block .)


state 34

    (3) block -> assignment .

    $end            reduce using rule 3 (block -> assignment .)
    RCORCH          reduce using rule 3 (block -> assignment .)


state 35

    (4) block -> function .

    $end            reduce using rule 4 (block -> function .)
    RCORCH          reduce using rule 4 (block -> function .)


state 36

    (5) block -> consult .

    $end            reduce using rule 5 (block -> consult .)
    RCORCH          reduce using rule 5 (block -> consult .)


state 37

    (6) block -> cycle .

    $end            reduce using rule 6 (block -> cycle .)
    RCORCH          reduce using rule 6 (block -> cycle .)


state 38

    (7) assignment -> identifier . ASSIGN a_content SEMICOLON block

    ASSIGN          shift and go to state 58


state 39

    (8) assignment -> GLOBAL . ID ASSIGN a_content SEMICOLON block

    ID              shift and go to state 59


state 40

    (9) assignment -> ID . COMMA ID ASSIGN value COMMA value SEMICOLON block
    (56) consult -> ID . PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> ID . PARENTCL INT TP INT PARENTCR SEMICOLON block
    (78) identifier -> ID .
    (22) insert -> ID . DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> ID . DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (80) complex_id -> ID . PARENTCL INT PARENTCR
    (81) complex_id -> ID . PARENTCL INT TP INT PARENTCR
    (82) complex_id -> ID . PARENTCL ID PARENTCR

    COMMA           shift and go to state 60
    PARENTCL        shift and go to state 61
    ASSIGN          reduce using rule 78 (identifier -> ID .)
    DOT             shift and go to state 62


state 41

    (10) assignment -> empty .

    $end            reduce using rule 10 (assignment -> empty .)
    RCORCH          reduce using rule 10 (assignment -> empty .)


state 42

    (11) function -> type .

    $end            reduce using rule 11 (function -> type .)
    RCORCH          reduce using rule 11 (function -> type .)


state 43

    (12) function -> insert .

    $end            reduce using rule 12 (function -> insert .)
    RCORCH          reduce using rule 12 (function -> insert .)


state 44

    (13) function -> del .

    $end            reduce using rule 13 (function -> del .)
    RCORCH          reduce using rule 13 (function -> del .)


state 45

    (14) function -> len .

    $end            reduce using rule 14 (function -> len .)
    RCORCH          reduce using rule 14 (function -> len .)


state 46

    (15) function -> neg .

    $end            reduce using rule 15 (function -> neg .)
    RCORCH          reduce using rule 15 (function -> neg .)


state 47

    (16) function -> t .

    $end            reduce using rule 16 (function -> t .)
    RCORCH          reduce using rule 16 (function -> t .)


state 48

    (17) function -> f .

    $end            reduce using rule 17 (function -> f .)
    RCORCH          reduce using rule 17 (function -> f .)


state 49

    (18) function -> blink .

    $end            reduce using rule 18 (function -> blink .)
    RCORCH          reduce using rule 18 (function -> blink .)


state 50

    (19) function -> delay .

    $end            reduce using rule 19 (function -> delay .)
    RCORCH          reduce using rule 19 (function -> delay .)


state 51

    (30) cycle -> for .

    $end            reduce using rule 30 (cycle -> for .)
    RCORCH          reduce using rule 30 (cycle -> for .)


state 52

    (79) identifier -> complex_id .
    (25) neg -> complex_id . DOT NEG SEMICOLON block
    (26) t -> complex_id . DOT T SEMICOLON block
    (27) f -> complex_id . DOT F SEMICOLON block

    ASSIGN          reduce using rule 79 (identifier -> complex_id .)
    DOT             shift and go to state 63


state 53

    (20) type -> TYPE . LPARENT ID RPARENT SEMICOLON block

    LPARENT         shift and go to state 64


state 54

    (24) len -> LEN . LPARENT ID RPARENT SEMICOLON block

    LPARENT         shift and go to state 65


state 55

    (28) blink -> BLINK . LPARENT b_content RPARENT SEMICOLON block

    LPARENT         shift and go to state 66


state 56

    (29) delay -> DELAY . LPARENT d_content RPARENT SEMICOLON block

    LPARENT         shift and go to state 67


state 57

    (31) for -> FOR . ID IN iterable step LCORCH block RCORCH SEMICOLON block

    ID              shift and go to state 68


state 58

    (7) assignment -> identifier ASSIGN . a_content SEMICOLON block
    (21) a_content -> . RANGE LPARENT INT COMMA value RPARENT
    (46) a_content -> . value
    (47) a_content -> . arithmetic
    (48) a_content -> . PARENTCL list_term PARENTCR
    (70) value -> . FALSE
    (71) value -> . TRUE
    (34) arithmetic -> . term
    (35) arithmetic -> . adding_operator term
    (36) arithmetic -> . arithmetic adding_operator term
    (37) term -> . factor
    (38) term -> . term multiplying_operator factor
    (63) adding_operator -> . PLUS
    (64) adding_operator -> . MINUS
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    RANGE           shift and go to state 70
    PARENTCL        shift and go to state 75
    FALSE           shift and go to state 76
    TRUE            shift and go to state 77
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    a_content                      shift and go to state 69
    value                          shift and go to state 73
    arithmetic                     shift and go to state 74
    term                           shift and go to state 78
    adding_operator                shift and go to state 79
    factor                         shift and go to state 80

state 59

    (8) assignment -> GLOBAL ID . ASSIGN a_content SEMICOLON block

    ASSIGN          shift and go to state 84


state 60

    (9) assignment -> ID COMMA . ID ASSIGN value COMMA value SEMICOLON block

    ID              shift and go to state 85


state 61

    (56) consult -> ID PARENTCL . INT PARENTCR SEMICOLON block
    (57) consult -> ID PARENTCL . INT TP INT PARENTCR SEMICOLON block
    (80) complex_id -> ID PARENTCL . INT PARENTCR
    (81) complex_id -> ID PARENTCL . INT TP INT PARENTCR
    (82) complex_id -> ID PARENTCL . ID PARENTCR

    INT             shift and go to state 87
    ID              shift and go to state 86


state 62

    (22) insert -> ID DOT . INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> ID DOT . DELETE LPARENT INT RPARENT SEMICOLON block

    INSERT          shift and go to state 88
    DELETE          shift and go to state 89


state 63

    (25) neg -> complex_id DOT . NEG SEMICOLON block
    (26) t -> complex_id DOT . T SEMICOLON block
    (27) f -> complex_id DOT . F SEMICOLON block

    NEG             shift and go to state 90
    T               shift and go to state 91
    F               shift and go to state 92


state 64

    (20) type -> TYPE LPARENT . ID RPARENT SEMICOLON block

    ID              shift and go to state 93


state 65

    (24) len -> LEN LPARENT . ID RPARENT SEMICOLON block

    ID              shift and go to state 94


state 66

    (28) blink -> BLINK LPARENT . b_content RPARENT SEMICOLON block
    (49) b_content -> . complex_id COMMA INT COMMA time_mes COMMA value
    (50) b_content -> . complex_id COMMA value
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    ID              shift and go to state 97

    b_content                      shift and go to state 95
    complex_id                     shift and go to state 96

state 67

    (29) delay -> DELAY LPARENT . d_content RPARENT SEMICOLON block
    (51) d_content -> . empty
    (52) d_content -> . INT COMMA time_mes
    (85) empty -> .

    INT             shift and go to state 100
    RPARENT         reduce using rule 85 (empty -> .)

    d_content                      shift and go to state 98
    empty                          shift and go to state 99

state 68

    (31) for -> FOR ID . IN iterable step LCORCH block RCORCH SEMICOLON block

    IN              shift and go to state 101


state 69

    (7) assignment -> identifier ASSIGN a_content . SEMICOLON block

    SEMICOLON       shift and go to state 102


state 70

    (21) a_content -> RANGE . LPARENT INT COMMA value RPARENT

    LPARENT         shift and go to state 103


state 71

    (41) factor -> LPARENT . arithmetic RPARENT
    (34) arithmetic -> . term
    (35) arithmetic -> . adding_operator term
    (36) arithmetic -> . arithmetic adding_operator term
    (37) term -> . factor
    (38) term -> . term multiplying_operator factor
    (63) adding_operator -> . PLUS
    (64) adding_operator -> . MINUS
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    arithmetic                     shift and go to state 104
    term                           shift and go to state 78
    adding_operator                shift and go to state 79
    factor                         shift and go to state 80

state 72

    (39) factor -> INT .

    TIMES           reduce using rule 39 (factor -> INT .)
    EXP             reduce using rule 39 (factor -> INT .)
    DIVIDE          reduce using rule 39 (factor -> INT .)
    DIVENT          reduce using rule 39 (factor -> INT .)
    MOD             reduce using rule 39 (factor -> INT .)
    PLUS            reduce using rule 39 (factor -> INT .)
    MINUS           reduce using rule 39 (factor -> INT .)
    SEMICOLON       reduce using rule 39 (factor -> INT .)
    RPARENT         reduce using rule 39 (factor -> INT .)


state 73

    (46) a_content -> value .

    SEMICOLON       reduce using rule 46 (a_content -> value .)


state 74

    (47) a_content -> arithmetic .
    (36) arithmetic -> arithmetic . adding_operator term
    (63) adding_operator -> . PLUS
    (64) adding_operator -> . MINUS

    SEMICOLON       reduce using rule 47 (a_content -> arithmetic .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82

    adding_operator                shift and go to state 105

state 75

    (48) a_content -> PARENTCL . list_term PARENTCR
    (53) list_term -> . value COMMA list_term
    (54) list_term -> . value
    (55) list_term -> .
    (70) value -> . FALSE
    (71) value -> . TRUE

    PARENTCR        reduce using rule 55 (list_term -> .)
    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    list_term                      shift and go to state 106
    value                          shift and go to state 107

state 76

    (70) value -> FALSE .

    SEMICOLON       reduce using rule 70 (value -> FALSE .)
    COMMA           reduce using rule 70 (value -> FALSE .)
    PARENTCR        reduce using rule 70 (value -> FALSE .)
    RPARENT         reduce using rule 70 (value -> FALSE .)


state 77

    (71) value -> TRUE .

    SEMICOLON       reduce using rule 71 (value -> TRUE .)
    COMMA           reduce using rule 71 (value -> TRUE .)
    PARENTCR        reduce using rule 71 (value -> TRUE .)
    RPARENT         reduce using rule 71 (value -> TRUE .)


state 78

    (34) arithmetic -> term .
    (38) term -> term . multiplying_operator factor
    (65) multiplying_operator -> . TIMES
    (66) multiplying_operator -> . EXP
    (67) multiplying_operator -> . DIVIDE
    (68) multiplying_operator -> . DIVENT
    (69) multiplying_operator -> . MOD

    PLUS            reduce using rule 34 (arithmetic -> term .)
    MINUS           reduce using rule 34 (arithmetic -> term .)
    SEMICOLON       reduce using rule 34 (arithmetic -> term .)
    RPARENT         reduce using rule 34 (arithmetic -> term .)
    TIMES           shift and go to state 109
    EXP             shift and go to state 110
    DIVIDE          shift and go to state 111
    DIVENT          shift and go to state 112
    MOD             shift and go to state 113

    multiplying_operator           shift and go to state 108

state 79

    (35) arithmetic -> adding_operator . term
    (37) term -> . factor
    (38) term -> . term multiplying_operator factor
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    term                           shift and go to state 114
    factor                         shift and go to state 80

state 80

    (37) term -> factor .

    TIMES           reduce using rule 37 (term -> factor .)
    EXP             reduce using rule 37 (term -> factor .)
    DIVIDE          reduce using rule 37 (term -> factor .)
    DIVENT          reduce using rule 37 (term -> factor .)
    MOD             reduce using rule 37 (term -> factor .)
    PLUS            reduce using rule 37 (term -> factor .)
    MINUS           reduce using rule 37 (term -> factor .)
    SEMICOLON       reduce using rule 37 (term -> factor .)
    RPARENT         reduce using rule 37 (term -> factor .)


state 81

    (63) adding_operator -> PLUS .

    INT             reduce using rule 63 (adding_operator -> PLUS .)
    ID              reduce using rule 63 (adding_operator -> PLUS .)
    LPARENT         reduce using rule 63 (adding_operator -> PLUS .)


state 82

    (64) adding_operator -> MINUS .

    INT             reduce using rule 64 (adding_operator -> MINUS .)
    ID              reduce using rule 64 (adding_operator -> MINUS .)
    LPARENT         reduce using rule 64 (adding_operator -> MINUS .)


state 83

    (40) factor -> ID .

    TIMES           reduce using rule 40 (factor -> ID .)
    EXP             reduce using rule 40 (factor -> ID .)
    DIVIDE          reduce using rule 40 (factor -> ID .)
    DIVENT          reduce using rule 40 (factor -> ID .)
    MOD             reduce using rule 40 (factor -> ID .)
    PLUS            reduce using rule 40 (factor -> ID .)
    MINUS           reduce using rule 40 (factor -> ID .)
    SEMICOLON       reduce using rule 40 (factor -> ID .)
    RPARENT         reduce using rule 40 (factor -> ID .)


state 84

    (8) assignment -> GLOBAL ID ASSIGN . a_content SEMICOLON block
    (21) a_content -> . RANGE LPARENT INT COMMA value RPARENT
    (46) a_content -> . value
    (47) a_content -> . arithmetic
    (48) a_content -> . PARENTCL list_term PARENTCR
    (70) value -> . FALSE
    (71) value -> . TRUE
    (34) arithmetic -> . term
    (35) arithmetic -> . adding_operator term
    (36) arithmetic -> . arithmetic adding_operator term
    (37) term -> . factor
    (38) term -> . term multiplying_operator factor
    (63) adding_operator -> . PLUS
    (64) adding_operator -> . MINUS
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    RANGE           shift and go to state 70
    PARENTCL        shift and go to state 75
    FALSE           shift and go to state 76
    TRUE            shift and go to state 77
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    a_content                      shift and go to state 115
    value                          shift and go to state 73
    arithmetic                     shift and go to state 74
    term                           shift and go to state 78
    adding_operator                shift and go to state 79
    factor                         shift and go to state 80

state 85

    (9) assignment -> ID COMMA ID . ASSIGN value COMMA value SEMICOLON block

    ASSIGN          shift and go to state 116


state 86

    (82) complex_id -> ID PARENTCL ID . PARENTCR

    PARENTCR        shift and go to state 117


state 87

    (56) consult -> ID PARENTCL INT . PARENTCR SEMICOLON block
    (57) consult -> ID PARENTCL INT . TP INT PARENTCR SEMICOLON block
    (80) complex_id -> ID PARENTCL INT . PARENTCR
    (81) complex_id -> ID PARENTCL INT . TP INT PARENTCR

    PARENTCR        shift and go to state 118
    TP              shift and go to state 119


state 88

    (22) insert -> ID DOT INSERT . LPARENT INT COMMA value RPARENT SEMICOLON block

    LPARENT         shift and go to state 120


state 89

    (23) del -> ID DOT DELETE . LPARENT INT RPARENT SEMICOLON block

    LPARENT         shift and go to state 121


state 90

    (25) neg -> complex_id DOT NEG . SEMICOLON block

    SEMICOLON       shift and go to state 122


state 91

    (26) t -> complex_id DOT T . SEMICOLON block

    SEMICOLON       shift and go to state 123


state 92

    (27) f -> complex_id DOT F . SEMICOLON block

    SEMICOLON       shift and go to state 124


state 93

    (20) type -> TYPE LPARENT ID . RPARENT SEMICOLON block

    RPARENT         shift and go to state 125


state 94

    (24) len -> LEN LPARENT ID . RPARENT SEMICOLON block

    RPARENT         shift and go to state 126


state 95

    (28) blink -> BLINK LPARENT b_content . RPARENT SEMICOLON block

    RPARENT         shift and go to state 127


state 96

    (49) b_content -> complex_id . COMMA INT COMMA time_mes COMMA value
    (50) b_content -> complex_id . COMMA value

    COMMA           shift and go to state 128


state 97

    (80) complex_id -> ID . PARENTCL INT PARENTCR
    (81) complex_id -> ID . PARENTCL INT TP INT PARENTCR
    (82) complex_id -> ID . PARENTCL ID PARENTCR

    PARENTCL        shift and go to state 129


state 98

    (29) delay -> DELAY LPARENT d_content . RPARENT SEMICOLON block

    RPARENT         shift and go to state 130


state 99

    (51) d_content -> empty .

    RPARENT         reduce using rule 51 (d_content -> empty .)


state 100

    (52) d_content -> INT . COMMA time_mes

    COMMA           shift and go to state 131


state 101

    (31) for -> FOR ID IN . iterable step LCORCH block RCORCH SEMICOLON block
    (83) iterable -> . identifier
    (84) iterable -> . INT
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    INT             shift and go to state 135
    ID              shift and go to state 132

    iterable                       shift and go to state 133
    identifier                     shift and go to state 134
    complex_id                     shift and go to state 136

state 102

    (7) assignment -> identifier ASSIGN a_content SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    identifier                     shift and go to state 38
    block                          shift and go to state 137
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 103

    (21) a_content -> RANGE LPARENT . INT COMMA value RPARENT

    INT             shift and go to state 138


state 104

    (41) factor -> LPARENT arithmetic . RPARENT
    (36) arithmetic -> arithmetic . adding_operator term
    (63) adding_operator -> . PLUS
    (64) adding_operator -> . MINUS

    RPARENT         shift and go to state 139
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82

    adding_operator                shift and go to state 105

state 105

    (36) arithmetic -> arithmetic adding_operator . term
    (37) term -> . factor
    (38) term -> . term multiplying_operator factor
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    term                           shift and go to state 140
    factor                         shift and go to state 80

state 106

    (48) a_content -> PARENTCL list_term . PARENTCR

    PARENTCR        shift and go to state 141


state 107

    (53) list_term -> value . COMMA list_term
    (54) list_term -> value .

    COMMA           shift and go to state 142
    PARENTCR        reduce using rule 54 (list_term -> value .)


state 108

    (38) term -> term multiplying_operator . factor
    (39) factor -> . INT
    (40) factor -> . ID
    (41) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 72
    ID              shift and go to state 83
    LPARENT         shift and go to state 71

    factor                         shift and go to state 143

state 109

    (65) multiplying_operator -> TIMES .

    INT             reduce using rule 65 (multiplying_operator -> TIMES .)
    ID              reduce using rule 65 (multiplying_operator -> TIMES .)
    LPARENT         reduce using rule 65 (multiplying_operator -> TIMES .)


state 110

    (66) multiplying_operator -> EXP .

    INT             reduce using rule 66 (multiplying_operator -> EXP .)
    ID              reduce using rule 66 (multiplying_operator -> EXP .)
    LPARENT         reduce using rule 66 (multiplying_operator -> EXP .)


state 111

    (67) multiplying_operator -> DIVIDE .

    INT             reduce using rule 67 (multiplying_operator -> DIVIDE .)
    ID              reduce using rule 67 (multiplying_operator -> DIVIDE .)
    LPARENT         reduce using rule 67 (multiplying_operator -> DIVIDE .)


state 112

    (68) multiplying_operator -> DIVENT .

    INT             reduce using rule 68 (multiplying_operator -> DIVENT .)
    ID              reduce using rule 68 (multiplying_operator -> DIVENT .)
    LPARENT         reduce using rule 68 (multiplying_operator -> DIVENT .)


state 113

    (69) multiplying_operator -> MOD .

    INT             reduce using rule 69 (multiplying_operator -> MOD .)
    ID              reduce using rule 69 (multiplying_operator -> MOD .)
    LPARENT         reduce using rule 69 (multiplying_operator -> MOD .)


state 114

    (35) arithmetic -> adding_operator term .
    (38) term -> term . multiplying_operator factor
    (65) multiplying_operator -> . TIMES
    (66) multiplying_operator -> . EXP
    (67) multiplying_operator -> . DIVIDE
    (68) multiplying_operator -> . DIVENT
    (69) multiplying_operator -> . MOD

    PLUS            reduce using rule 35 (arithmetic -> adding_operator term .)
    MINUS           reduce using rule 35 (arithmetic -> adding_operator term .)
    SEMICOLON       reduce using rule 35 (arithmetic -> adding_operator term .)
    RPARENT         reduce using rule 35 (arithmetic -> adding_operator term .)
    TIMES           shift and go to state 109
    EXP             shift and go to state 110
    DIVIDE          shift and go to state 111
    DIVENT          shift and go to state 112
    MOD             shift and go to state 113

    multiplying_operator           shift and go to state 108

state 115

    (8) assignment -> GLOBAL ID ASSIGN a_content . SEMICOLON block

    SEMICOLON       shift and go to state 144


state 116

    (9) assignment -> ID COMMA ID ASSIGN . value COMMA value SEMICOLON block
    (70) value -> . FALSE
    (71) value -> . TRUE

    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 145

state 117

    (82) complex_id -> ID PARENTCL ID PARENTCR .

    DOT             reduce using rule 82 (complex_id -> ID PARENTCL ID PARENTCR .)
    ASSIGN          reduce using rule 82 (complex_id -> ID PARENTCL ID PARENTCR .)
    COMMA           reduce using rule 82 (complex_id -> ID PARENTCL ID PARENTCR .)
    STEP            reduce using rule 82 (complex_id -> ID PARENTCL ID PARENTCR .)
    LCORCH          reduce using rule 82 (complex_id -> ID PARENTCL ID PARENTCR .)


state 118

    (56) consult -> ID PARENTCL INT PARENTCR . SEMICOLON block
    (80) complex_id -> ID PARENTCL INT PARENTCR .

    SEMICOLON       shift and go to state 146
    DOT             reduce using rule 80 (complex_id -> ID PARENTCL INT PARENTCR .)
    ASSIGN          reduce using rule 80 (complex_id -> ID PARENTCL INT PARENTCR .)


state 119

    (57) consult -> ID PARENTCL INT TP . INT PARENTCR SEMICOLON block
    (81) complex_id -> ID PARENTCL INT TP . INT PARENTCR

    INT             shift and go to state 147


state 120

    (22) insert -> ID DOT INSERT LPARENT . INT COMMA value RPARENT SEMICOLON block

    INT             shift and go to state 148


state 121

    (23) del -> ID DOT DELETE LPARENT . INT RPARENT SEMICOLON block

    INT             shift and go to state 149


state 122

    (25) neg -> complex_id DOT NEG SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    complex_id                     shift and go to state 52
    block                          shift and go to state 150
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51

state 123

    (26) t -> complex_id DOT T SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    complex_id                     shift and go to state 52
    block                          shift and go to state 151
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51

state 124

    (27) f -> complex_id DOT F SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    complex_id                     shift and go to state 52
    block                          shift and go to state 152
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51

state 125

    (20) type -> TYPE LPARENT ID RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 153


state 126

    (24) len -> LEN LPARENT ID RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 154


state 127

    (28) blink -> BLINK LPARENT b_content RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 155


state 128

    (49) b_content -> complex_id COMMA . INT COMMA time_mes COMMA value
    (50) b_content -> complex_id COMMA . value
    (70) value -> . FALSE
    (71) value -> . TRUE

    INT             shift and go to state 156
    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 157

state 129

    (80) complex_id -> ID PARENTCL . INT PARENTCR
    (81) complex_id -> ID PARENTCL . INT TP INT PARENTCR
    (82) complex_id -> ID PARENTCL . ID PARENTCR

    INT             shift and go to state 158
    ID              shift and go to state 86


state 130

    (29) delay -> DELAY LPARENT d_content RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 159


state 131

    (52) d_content -> INT COMMA . time_mes
    (60) time_mes -> . QUOTES MIL QUOTES
    (61) time_mes -> . QUOTES MIN QUOTES
    (62) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 160

state 132

    (78) identifier -> ID .
    (80) complex_id -> ID . PARENTCL INT PARENTCR
    (81) complex_id -> ID . PARENTCL INT TP INT PARENTCR
    (82) complex_id -> ID . PARENTCL ID PARENTCR

    STEP            reduce using rule 78 (identifier -> ID .)
    LCORCH          reduce using rule 78 (identifier -> ID .)
    PARENTCL        shift and go to state 129


state 133

    (31) for -> FOR ID IN iterable . step LCORCH block RCORCH SEMICOLON block
    (32) step -> . STEP INT
    (33) step -> . empty
    (85) empty -> .

    STEP            shift and go to state 162
    LCORCH          reduce using rule 85 (empty -> .)

    step                           shift and go to state 161
    empty                          shift and go to state 163

state 134

    (83) iterable -> identifier .

    STEP            reduce using rule 83 (iterable -> identifier .)
    LCORCH          reduce using rule 83 (iterable -> identifier .)


state 135

    (84) iterable -> INT .

    STEP            reduce using rule 84 (iterable -> INT .)
    LCORCH          reduce using rule 84 (iterable -> INT .)


state 136

    (79) identifier -> complex_id .

    STEP            reduce using rule 79 (identifier -> complex_id .)
    LCORCH          reduce using rule 79 (identifier -> complex_id .)


state 137

    (7) assignment -> identifier ASSIGN a_content SEMICOLON block .

    $end            reduce using rule 7 (assignment -> identifier ASSIGN a_content SEMICOLON block .)
    RCORCH          reduce using rule 7 (assignment -> identifier ASSIGN a_content SEMICOLON block .)


state 138

    (21) a_content -> RANGE LPARENT INT . COMMA value RPARENT

    COMMA           shift and go to state 164


state 139

    (41) factor -> LPARENT arithmetic RPARENT .

    TIMES           reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    EXP             reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    DIVIDE          reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    DIVENT          reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    MOD             reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    PLUS            reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    MINUS           reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    SEMICOLON       reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)
    RPARENT         reduce using rule 41 (factor -> LPARENT arithmetic RPARENT .)


state 140

    (36) arithmetic -> arithmetic adding_operator term .
    (38) term -> term . multiplying_operator factor
    (65) multiplying_operator -> . TIMES
    (66) multiplying_operator -> . EXP
    (67) multiplying_operator -> . DIVIDE
    (68) multiplying_operator -> . DIVENT
    (69) multiplying_operator -> . MOD

    PLUS            reduce using rule 36 (arithmetic -> arithmetic adding_operator term .)
    MINUS           reduce using rule 36 (arithmetic -> arithmetic adding_operator term .)
    SEMICOLON       reduce using rule 36 (arithmetic -> arithmetic adding_operator term .)
    RPARENT         reduce using rule 36 (arithmetic -> arithmetic adding_operator term .)
    TIMES           shift and go to state 109
    EXP             shift and go to state 110
    DIVIDE          shift and go to state 111
    DIVENT          shift and go to state 112
    MOD             shift and go to state 113

    multiplying_operator           shift and go to state 108

state 141

    (48) a_content -> PARENTCL list_term PARENTCR .

    SEMICOLON       reduce using rule 48 (a_content -> PARENTCL list_term PARENTCR .)


state 142

    (53) list_term -> value COMMA . list_term
    (53) list_term -> . value COMMA list_term
    (54) list_term -> . value
    (55) list_term -> .
    (70) value -> . FALSE
    (71) value -> . TRUE

    PARENTCR        reduce using rule 55 (list_term -> .)
    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 107
    list_term                      shift and go to state 165

state 143

    (38) term -> term multiplying_operator factor .

    TIMES           reduce using rule 38 (term -> term multiplying_operator factor .)
    EXP             reduce using rule 38 (term -> term multiplying_operator factor .)
    DIVIDE          reduce using rule 38 (term -> term multiplying_operator factor .)
    DIVENT          reduce using rule 38 (term -> term multiplying_operator factor .)
    MOD             reduce using rule 38 (term -> term multiplying_operator factor .)
    PLUS            reduce using rule 38 (term -> term multiplying_operator factor .)
    MINUS           reduce using rule 38 (term -> term multiplying_operator factor .)
    SEMICOLON       reduce using rule 38 (term -> term multiplying_operator factor .)
    RPARENT         reduce using rule 38 (term -> term multiplying_operator factor .)


state 144

    (8) assignment -> GLOBAL ID ASSIGN a_content SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 166
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 145

    (9) assignment -> ID COMMA ID ASSIGN value . COMMA value SEMICOLON block

    COMMA           shift and go to state 167


state 146

    (56) consult -> ID PARENTCL INT PARENTCR SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 168
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 147

    (57) consult -> ID PARENTCL INT TP INT . PARENTCR SEMICOLON block
    (81) complex_id -> ID PARENTCL INT TP INT . PARENTCR

    PARENTCR        shift and go to state 169


state 148

    (22) insert -> ID DOT INSERT LPARENT INT . COMMA value RPARENT SEMICOLON block

    COMMA           shift and go to state 170


state 149

    (23) del -> ID DOT DELETE LPARENT INT . RPARENT SEMICOLON block

    RPARENT         shift and go to state 171


state 150

    (25) neg -> complex_id DOT NEG SEMICOLON block .

    $end            reduce using rule 25 (neg -> complex_id DOT NEG SEMICOLON block .)
    RCORCH          reduce using rule 25 (neg -> complex_id DOT NEG SEMICOLON block .)


state 151

    (26) t -> complex_id DOT T SEMICOLON block .

    $end            reduce using rule 26 (t -> complex_id DOT T SEMICOLON block .)
    RCORCH          reduce using rule 26 (t -> complex_id DOT T SEMICOLON block .)


state 152

    (27) f -> complex_id DOT F SEMICOLON block .

    $end            reduce using rule 27 (f -> complex_id DOT F SEMICOLON block .)
    RCORCH          reduce using rule 27 (f -> complex_id DOT F SEMICOLON block .)


state 153

    (20) type -> TYPE LPARENT ID RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 172
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 154

    (24) len -> LEN LPARENT ID RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 173
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 155

    (28) blink -> BLINK LPARENT b_content RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 174
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 156

    (49) b_content -> complex_id COMMA INT . COMMA time_mes COMMA value

    COMMA           shift and go to state 175


state 157

    (50) b_content -> complex_id COMMA value .

    RPARENT         reduce using rule 50 (b_content -> complex_id COMMA value .)


state 158

    (80) complex_id -> ID PARENTCL INT . PARENTCR
    (81) complex_id -> ID PARENTCL INT . TP INT PARENTCR

    PARENTCR        shift and go to state 176
    TP              shift and go to state 177


state 159

    (29) delay -> DELAY LPARENT d_content RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 178
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 160

    (52) d_content -> INT COMMA time_mes .

    RPARENT         reduce using rule 52 (d_content -> INT COMMA time_mes .)


state 161

    (31) for -> FOR ID IN iterable step . LCORCH block RCORCH SEMICOLON block

    LCORCH          shift and go to state 179


state 162

    (32) step -> STEP . INT

    INT             shift and go to state 180


state 163

    (33) step -> empty .

    LCORCH          reduce using rule 33 (step -> empty .)


state 164

    (21) a_content -> RANGE LPARENT INT COMMA . value RPARENT
    (70) value -> . FALSE
    (71) value -> . TRUE

    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 181

state 165

    (53) list_term -> value COMMA list_term .

    PARENTCR        reduce using rule 53 (list_term -> value COMMA list_term .)


state 166

    (8) assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .

    $end            reduce using rule 8 (assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .)
    RCORCH          reduce using rule 8 (assignment -> GLOBAL ID ASSIGN a_content SEMICOLON block .)


state 167

    (9) assignment -> ID COMMA ID ASSIGN value COMMA . value SEMICOLON block
    (70) value -> . FALSE
    (71) value -> . TRUE

    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 182

state 168

    (56) consult -> ID PARENTCL INT PARENTCR SEMICOLON block .

    $end            reduce using rule 56 (consult -> ID PARENTCL INT PARENTCR SEMICOLON block .)
    RCORCH          reduce using rule 56 (consult -> ID PARENTCL INT PARENTCR SEMICOLON block .)


state 169

    (57) consult -> ID PARENTCL INT TP INT PARENTCR . SEMICOLON block
    (81) complex_id -> ID PARENTCL INT TP INT PARENTCR .

    SEMICOLON       shift and go to state 183
    DOT             reduce using rule 81 (complex_id -> ID PARENTCL INT TP INT PARENTCR .)
    ASSIGN          reduce using rule 81 (complex_id -> ID PARENTCL INT TP INT PARENTCR .)


state 170

    (22) insert -> ID DOT INSERT LPARENT INT COMMA . value RPARENT SEMICOLON block
    (70) value -> . FALSE
    (71) value -> . TRUE

    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 184

state 171

    (23) del -> ID DOT DELETE LPARENT INT RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 185


state 172

    (20) type -> TYPE LPARENT ID RPARENT SEMICOLON block .

    $end            reduce using rule 20 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 20 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)


state 173

    (24) len -> LEN LPARENT ID RPARENT SEMICOLON block .

    $end            reduce using rule 24 (len -> LEN LPARENT ID RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 24 (len -> LEN LPARENT ID RPARENT SEMICOLON block .)


state 174

    (28) blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .

    $end            reduce using rule 28 (blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 28 (blink -> BLINK LPARENT b_content RPARENT SEMICOLON block .)


state 175

    (49) b_content -> complex_id COMMA INT COMMA . time_mes COMMA value
    (60) time_mes -> . QUOTES MIL QUOTES
    (61) time_mes -> . QUOTES MIN QUOTES
    (62) time_mes -> . QUOTES SEG QUOTES

    QUOTES          shift and go to state 18

    time_mes                       shift and go to state 186

state 176

    (80) complex_id -> ID PARENTCL INT PARENTCR .

    COMMA           reduce using rule 80 (complex_id -> ID PARENTCL INT PARENTCR .)
    STEP            reduce using rule 80 (complex_id -> ID PARENTCL INT PARENTCR .)
    LCORCH          reduce using rule 80 (complex_id -> ID PARENTCL INT PARENTCR .)


state 177

    (81) complex_id -> ID PARENTCL INT TP . INT PARENTCR

    INT             shift and go to state 187


state 178

    (29) delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .

    $end            reduce using rule 29 (delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 29 (delay -> DELAY LPARENT d_content RPARENT SEMICOLON block .)


state 179

    (31) for -> FOR ID IN iterable step LCORCH . block RCORCH SEMICOLON block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 188
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 180

    (32) step -> STEP INT .

    LCORCH          reduce using rule 32 (step -> STEP INT .)


state 181

    (21) a_content -> RANGE LPARENT INT COMMA value . RPARENT

    RPARENT         shift and go to state 189


state 182

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value . SEMICOLON block

    SEMICOLON       shift and go to state 190


state 183

    (57) consult -> ID PARENTCL INT TP INT PARENTCR SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 191
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 184

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value . RPARENT SEMICOLON block

    RPARENT         shift and go to state 192


state 185

    (23) del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 193
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 186

    (49) b_content -> complex_id COMMA INT COMMA time_mes . COMMA value

    COMMA           shift and go to state 194


state 187

    (81) complex_id -> ID PARENTCL INT TP INT . PARENTCR

    PARENTCR        shift and go to state 195


state 188

    (31) for -> FOR ID IN iterable step LCORCH block . RCORCH SEMICOLON block

    RCORCH          shift and go to state 196


state 189

    (21) a_content -> RANGE LPARENT INT COMMA value RPARENT .

    SEMICOLON       reduce using rule 21 (a_content -> RANGE LPARENT INT COMMA value RPARENT .)


state 190

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 197
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 191

    (57) consult -> ID PARENTCL INT TP INT PARENTCR SEMICOLON block .

    $end            reduce using rule 57 (consult -> ID PARENTCL INT TP INT PARENTCR SEMICOLON block .)
    RCORCH          reduce using rule 57 (consult -> ID PARENTCL INT TP INT PARENTCR SEMICOLON block .)


state 192

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 198


state 193

    (23) del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .

    $end            reduce using rule 23 (del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 23 (del -> ID DOT DELETE LPARENT INT RPARENT SEMICOLON block .)


state 194

    (49) b_content -> complex_id COMMA INT COMMA time_mes COMMA . value
    (70) value -> . FALSE
    (71) value -> . TRUE

    FALSE           shift and go to state 76
    TRUE            shift and go to state 77

    value                          shift and go to state 199

state 195

    (81) complex_id -> ID PARENTCL INT TP INT PARENTCR .

    COMMA           reduce using rule 81 (complex_id -> ID PARENTCL INT TP INT PARENTCR .)
    STEP            reduce using rule 81 (complex_id -> ID PARENTCL INT TP INT PARENTCR .)
    LCORCH          reduce using rule 81 (complex_id -> ID PARENTCL INT TP INT PARENTCR .)


state 196

    (31) for -> FOR ID IN iterable step LCORCH block RCORCH . SEMICOLON block

    SEMICOLON       shift and go to state 200


state 197

    (9) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .

    $end            reduce using rule 9 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)
    RCORCH          reduce using rule 9 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)


state 198

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 201
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 199

    (49) b_content -> complex_id COMMA INT COMMA time_mes COMMA value .

    RPARENT         reduce using rule 49 (b_content -> complex_id COMMA INT COMMA time_mes COMMA value .)


state 200

    (31) for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON . block
    (3) block -> . assignment
    (4) block -> . function
    (5) block -> . consult
    (6) block -> . cycle
    (7) assignment -> . identifier ASSIGN a_content SEMICOLON block
    (8) assignment -> . GLOBAL ID ASSIGN a_content SEMICOLON block
    (9) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (10) assignment -> . empty
    (11) function -> . type
    (12) function -> . insert
    (13) function -> . del
    (14) function -> . len
    (15) function -> . neg
    (16) function -> . t
    (17) function -> . f
    (18) function -> . blink
    (19) function -> . delay
    (56) consult -> . ID PARENTCL INT PARENTCR SEMICOLON block
    (57) consult -> . ID PARENTCL INT TP INT PARENTCR SEMICOLON block
    (30) cycle -> . for
    (78) identifier -> . ID
    (79) identifier -> . complex_id
    (85) empty -> .
    (20) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (22) insert -> . ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block
    (23) del -> . ID DOT DELETE LPARENT INT RPARENT SEMICOLON block
    (24) len -> . LEN LPARENT ID RPARENT SEMICOLON block
    (25) neg -> . complex_id DOT NEG SEMICOLON block
    (26) t -> . complex_id DOT T SEMICOLON block
    (27) f -> . complex_id DOT F SEMICOLON block
    (28) blink -> . BLINK LPARENT b_content RPARENT SEMICOLON block
    (29) delay -> . DELAY LPARENT d_content RPARENT SEMICOLON block
    (31) for -> . FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block
    (80) complex_id -> . ID PARENTCL INT PARENTCR
    (81) complex_id -> . ID PARENTCL INT TP INT PARENTCR
    (82) complex_id -> . ID PARENTCL ID PARENTCR

    GLOBAL          shift and go to state 39
    ID              shift and go to state 40
    $end            reduce using rule 85 (empty -> .)
    RCORCH          reduce using rule 85 (empty -> .)
    TYPE            shift and go to state 53
    LEN             shift and go to state 54
    BLINK           shift and go to state 55
    DELAY           shift and go to state 56
    FOR             shift and go to state 57

    block                          shift and go to state 202
    assignment                     shift and go to state 34
    function                       shift and go to state 35
    consult                        shift and go to state 36
    cycle                          shift and go to state 37
    identifier                     shift and go to state 38
    empty                          shift and go to state 41
    type                           shift and go to state 42
    insert                         shift and go to state 43
    del                            shift and go to state 44
    len                            shift and go to state 45
    neg                            shift and go to state 46
    t                              shift and go to state 47
    f                              shift and go to state 48
    blink                          shift and go to state 49
    delay                          shift and go to state 50
    for                            shift and go to state 51
    complex_id                     shift and go to state 52

state 201

    (22) insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .

    $end            reduce using rule 22 (insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .)
    RCORCH          reduce using rule 22 (insert -> ID DOT INSERT LPARENT INT COMMA value RPARENT SEMICOLON block .)


state 202

    (31) for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .

    $end            reduce using rule 31 (for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .)
    RCORCH          reduce using rule 31 (for -> FOR ID IN iterable step LCORCH block RCORCH SEMICOLON block .)

