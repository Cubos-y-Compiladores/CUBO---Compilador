Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLINK
    BOOKED
    CONST
    DELETE
    DOT
    ELSE
    F
    FOR
    GLOBAL
    IF
    INSERT
    LCORCH
    LEN
    LENGHTERROR
    MOD
    NEG
    PARENTCL
    PARENTCR
    PROCEDURE
    RANGE
    RCORCH
    T
    TP
    VARERROR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> assignment function
Rule 3     assignment -> ID ASSIGN value SEMICOLON block
Rule 4     assignment -> ID ASSIGN arithmetic SEMICOLON block
Rule 5     assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block
Rule 6     assignment -> empty
Rule 7     function -> type
Rule 8     function -> empty
Rule 9     type -> TYPE LPARENT ID RPARENT SEMICOLON block
Rule 10    arithmetic -> term
Rule 11    arithmetic -> adding_operator term
Rule 12    arithmetic -> arithmetic adding_operator term
Rule 13    term -> factor
Rule 14    term -> term multiplying_operator factor
Rule 15    factor -> INT
Rule 16    factor -> ID
Rule 17    factor -> LPARENT arithmetic RPARENT
Rule 18    adding_operator -> PLUS
Rule 19    adding_operator -> MINUS
Rule 20    multiplying_operator -> TIMES
Rule 21    multiplying_operator -> EXP
Rule 22    multiplying_operator -> DIVIDE
Rule 23    multiplying_operator -> DIVENT
Rule 24    value -> FALSE
Rule 25    value -> TRUE
Rule 26    value -> ID
Rule 27    value -> INT
Rule 28    relation -> ASSIGN
Rule 29    relation -> NE
Rule 30    relation -> LT
Rule 31    relation -> GT
Rule 32    relation -> LTE
Rule 33    relation -> GTE
Rule 34    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 3 4 5 28
BLINK                : 
BOOKED               : 
COMMA                : 5 5
CONST                : 
DELETE               : 
DIVENT               : 23
DIVIDE               : 22
DOT                  : 
ELSE                 : 
EXP                  : 21
F                    : 
FALSE                : 24
FOR                  : 
GLOBAL               : 
GT                   : 31
GTE                  : 33
ID                   : 3 4 5 5 9 16 26
IF                   : 
INSERT               : 
INT                  : 15 27
LCORCH               : 
LEN                  : 
LENGHTERROR          : 
LPARENT              : 9 17
LT                   : 30
LTE                  : 32
MINUS                : 19
MOD                  : 
NE                   : 29
NEG                  : 
PARENTCL             : 
PARENTCR             : 
PLUS                 : 18
PROCEDURE            : 
RANGE                : 
RCORCH               : 
RPARENT              : 9 17
SEMICOLON            : 3 4 5 9
T                    : 
TIMES                : 20
TP                   : 
TRUE                 : 25
TYPE                 : 9
VARERROR             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

adding_operator      : 11 12
arithmetic           : 4 12 17
assignment           : 2
block                : 1 3 4 5 9
empty                : 6 8
factor               : 13 14
function             : 2
multiplying_operator : 14
program              : 0
relation             : 
term                 : 10 11 12 14
type                 : 7
value                : 3 5 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . assignment function
    (3) assignment -> . ID ASSIGN value SEMICOLON block
    (4) assignment -> . ID ASSIGN arithmetic SEMICOLON block
    (5) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (6) assignment -> . empty
    (34) empty -> .

    ID              shift and go to state 4
    TYPE            reduce using rule 34 (empty -> .)
    $end            reduce using rule 34 (empty -> .)

    program                        shift and go to state 1
    block                          shift and go to state 2
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> assignment . function
    (7) function -> . type
    (8) function -> . empty
    (9) type -> . TYPE LPARENT ID RPARENT SEMICOLON block
    (34) empty -> .

  ! shift/reduce conflict for TYPE resolved as shift
    TYPE            shift and go to state 9
    $end            reduce using rule 34 (empty -> .)

  ! TYPE            [ reduce using rule 34 (empty -> .) ]

    function                       shift and go to state 6
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 4

    (3) assignment -> ID . ASSIGN value SEMICOLON block
    (4) assignment -> ID . ASSIGN arithmetic SEMICOLON block
    (5) assignment -> ID . COMMA ID ASSIGN value COMMA value SEMICOLON block

    ASSIGN          shift and go to state 10
    COMMA           shift and go to state 11


state 5

    (6) assignment -> empty .

    TYPE            reduce using rule 6 (assignment -> empty .)
    $end            reduce using rule 6 (assignment -> empty .)


state 6

    (2) block -> assignment function .

    $end            reduce using rule 2 (block -> assignment function .)
    TYPE            reduce using rule 2 (block -> assignment function .)


state 7

    (7) function -> type .

    $end            reduce using rule 7 (function -> type .)
    TYPE            reduce using rule 7 (function -> type .)


state 8

    (8) function -> empty .

    $end            reduce using rule 8 (function -> empty .)
    TYPE            reduce using rule 8 (function -> empty .)


state 9

    (9) type -> TYPE . LPARENT ID RPARENT SEMICOLON block

    LPARENT         shift and go to state 12


state 10

    (3) assignment -> ID ASSIGN . value SEMICOLON block
    (4) assignment -> ID ASSIGN . arithmetic SEMICOLON block
    (24) value -> . FALSE
    (25) value -> . TRUE
    (26) value -> . ID
    (27) value -> . INT
    (10) arithmetic -> . term
    (11) arithmetic -> . adding_operator term
    (12) arithmetic -> . arithmetic adding_operator term
    (13) term -> . factor
    (14) term -> . term multiplying_operator factor
    (18) adding_operator -> . PLUS
    (19) adding_operator -> . MINUS
    (15) factor -> . INT
    (16) factor -> . ID
    (17) factor -> . LPARENT arithmetic RPARENT

    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 18
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    LPARENT         shift and go to state 24

    value                          shift and go to state 14
    arithmetic                     shift and go to state 15
    term                           shift and go to state 19
    adding_operator                shift and go to state 20
    factor                         shift and go to state 21

state 11

    (5) assignment -> ID COMMA . ID ASSIGN value COMMA value SEMICOLON block

    ID              shift and go to state 25


state 12

    (9) type -> TYPE LPARENT . ID RPARENT SEMICOLON block

    ID              shift and go to state 26


state 13

    (26) value -> ID .
    (16) factor -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 16 (factor -> ID .)
    TIMES           reduce using rule 16 (factor -> ID .)
    EXP             reduce using rule 16 (factor -> ID .)
    DIVIDE          reduce using rule 16 (factor -> ID .)
    DIVENT          reduce using rule 16 (factor -> ID .)
    SEMICOLON       reduce using rule 16 (factor -> ID .)
    PLUS            reduce using rule 16 (factor -> ID .)
    MINUS           reduce using rule 16 (factor -> ID .)

  ! SEMICOLON       [ reduce using rule 26 (value -> ID .) ]


state 14

    (3) assignment -> ID ASSIGN value . SEMICOLON block

    SEMICOLON       shift and go to state 27


state 15

    (4) assignment -> ID ASSIGN arithmetic . SEMICOLON block
    (12) arithmetic -> arithmetic . adding_operator term
    (18) adding_operator -> . PLUS
    (19) adding_operator -> . MINUS

    SEMICOLON       shift and go to state 28
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23

    adding_operator                shift and go to state 29

state 16

    (24) value -> FALSE .

    SEMICOLON       reduce using rule 24 (value -> FALSE .)
    COMMA           reduce using rule 24 (value -> FALSE .)


state 17

    (25) value -> TRUE .

    SEMICOLON       reduce using rule 25 (value -> TRUE .)
    COMMA           reduce using rule 25 (value -> TRUE .)


state 18

    (27) value -> INT .
    (15) factor -> INT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 15 (factor -> INT .)
    TIMES           reduce using rule 15 (factor -> INT .)
    EXP             reduce using rule 15 (factor -> INT .)
    DIVIDE          reduce using rule 15 (factor -> INT .)
    DIVENT          reduce using rule 15 (factor -> INT .)
    SEMICOLON       reduce using rule 15 (factor -> INT .)
    PLUS            reduce using rule 15 (factor -> INT .)
    MINUS           reduce using rule 15 (factor -> INT .)

  ! SEMICOLON       [ reduce using rule 27 (value -> INT .) ]


state 19

    (10) arithmetic -> term .
    (14) term -> term . multiplying_operator factor
    (20) multiplying_operator -> . TIMES
    (21) multiplying_operator -> . EXP
    (22) multiplying_operator -> . DIVIDE
    (23) multiplying_operator -> . DIVENT

    SEMICOLON       reduce using rule 10 (arithmetic -> term .)
    PLUS            reduce using rule 10 (arithmetic -> term .)
    MINUS           reduce using rule 10 (arithmetic -> term .)
    RPARENT         reduce using rule 10 (arithmetic -> term .)
    TIMES           shift and go to state 31
    EXP             shift and go to state 32
    DIVIDE          shift and go to state 33
    DIVENT          shift and go to state 34

    multiplying_operator           shift and go to state 30

state 20

    (11) arithmetic -> adding_operator . term
    (13) term -> . factor
    (14) term -> . term multiplying_operator factor
    (15) factor -> . INT
    (16) factor -> . ID
    (17) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 36
    ID              shift and go to state 37
    LPARENT         shift and go to state 24

    term                           shift and go to state 35
    factor                         shift and go to state 21

state 21

    (13) term -> factor .

    TIMES           reduce using rule 13 (term -> factor .)
    EXP             reduce using rule 13 (term -> factor .)
    DIVIDE          reduce using rule 13 (term -> factor .)
    DIVENT          reduce using rule 13 (term -> factor .)
    SEMICOLON       reduce using rule 13 (term -> factor .)
    PLUS            reduce using rule 13 (term -> factor .)
    MINUS           reduce using rule 13 (term -> factor .)
    RPARENT         reduce using rule 13 (term -> factor .)


state 22

    (18) adding_operator -> PLUS .

    INT             reduce using rule 18 (adding_operator -> PLUS .)
    ID              reduce using rule 18 (adding_operator -> PLUS .)
    LPARENT         reduce using rule 18 (adding_operator -> PLUS .)


state 23

    (19) adding_operator -> MINUS .

    INT             reduce using rule 19 (adding_operator -> MINUS .)
    ID              reduce using rule 19 (adding_operator -> MINUS .)
    LPARENT         reduce using rule 19 (adding_operator -> MINUS .)


state 24

    (17) factor -> LPARENT . arithmetic RPARENT
    (10) arithmetic -> . term
    (11) arithmetic -> . adding_operator term
    (12) arithmetic -> . arithmetic adding_operator term
    (13) term -> . factor
    (14) term -> . term multiplying_operator factor
    (18) adding_operator -> . PLUS
    (19) adding_operator -> . MINUS
    (15) factor -> . INT
    (16) factor -> . ID
    (17) factor -> . LPARENT arithmetic RPARENT

    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    INT             shift and go to state 36
    ID              shift and go to state 37
    LPARENT         shift and go to state 24

    arithmetic                     shift and go to state 38
    term                           shift and go to state 19
    adding_operator                shift and go to state 20
    factor                         shift and go to state 21

state 25

    (5) assignment -> ID COMMA ID . ASSIGN value COMMA value SEMICOLON block

    ASSIGN          shift and go to state 39


state 26

    (9) type -> TYPE LPARENT ID . RPARENT SEMICOLON block

    RPARENT         shift and go to state 40


state 27

    (3) assignment -> ID ASSIGN value SEMICOLON . block
    (2) block -> . assignment function
    (3) assignment -> . ID ASSIGN value SEMICOLON block
    (4) assignment -> . ID ASSIGN arithmetic SEMICOLON block
    (5) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (6) assignment -> . empty
    (34) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 34 (empty -> .)
    TYPE            reduce using rule 34 (empty -> .)

    block                          shift and go to state 41
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 28

    (4) assignment -> ID ASSIGN arithmetic SEMICOLON . block
    (2) block -> . assignment function
    (3) assignment -> . ID ASSIGN value SEMICOLON block
    (4) assignment -> . ID ASSIGN arithmetic SEMICOLON block
    (5) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (6) assignment -> . empty
    (34) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 34 (empty -> .)
    TYPE            reduce using rule 34 (empty -> .)

    block                          shift and go to state 42
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 29

    (12) arithmetic -> arithmetic adding_operator . term
    (13) term -> . factor
    (14) term -> . term multiplying_operator factor
    (15) factor -> . INT
    (16) factor -> . ID
    (17) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 36
    ID              shift and go to state 37
    LPARENT         shift and go to state 24

    term                           shift and go to state 43
    factor                         shift and go to state 21

state 30

    (14) term -> term multiplying_operator . factor
    (15) factor -> . INT
    (16) factor -> . ID
    (17) factor -> . LPARENT arithmetic RPARENT

    INT             shift and go to state 36
    ID              shift and go to state 37
    LPARENT         shift and go to state 24

    factor                         shift and go to state 44

state 31

    (20) multiplying_operator -> TIMES .

    INT             reduce using rule 20 (multiplying_operator -> TIMES .)
    ID              reduce using rule 20 (multiplying_operator -> TIMES .)
    LPARENT         reduce using rule 20 (multiplying_operator -> TIMES .)


state 32

    (21) multiplying_operator -> EXP .

    INT             reduce using rule 21 (multiplying_operator -> EXP .)
    ID              reduce using rule 21 (multiplying_operator -> EXP .)
    LPARENT         reduce using rule 21 (multiplying_operator -> EXP .)


state 33

    (22) multiplying_operator -> DIVIDE .

    INT             reduce using rule 22 (multiplying_operator -> DIVIDE .)
    ID              reduce using rule 22 (multiplying_operator -> DIVIDE .)
    LPARENT         reduce using rule 22 (multiplying_operator -> DIVIDE .)


state 34

    (23) multiplying_operator -> DIVENT .

    INT             reduce using rule 23 (multiplying_operator -> DIVENT .)
    ID              reduce using rule 23 (multiplying_operator -> DIVENT .)
    LPARENT         reduce using rule 23 (multiplying_operator -> DIVENT .)


state 35

    (11) arithmetic -> adding_operator term .
    (14) term -> term . multiplying_operator factor
    (20) multiplying_operator -> . TIMES
    (21) multiplying_operator -> . EXP
    (22) multiplying_operator -> . DIVIDE
    (23) multiplying_operator -> . DIVENT

    SEMICOLON       reduce using rule 11 (arithmetic -> adding_operator term .)
    PLUS            reduce using rule 11 (arithmetic -> adding_operator term .)
    MINUS           reduce using rule 11 (arithmetic -> adding_operator term .)
    RPARENT         reduce using rule 11 (arithmetic -> adding_operator term .)
    TIMES           shift and go to state 31
    EXP             shift and go to state 32
    DIVIDE          shift and go to state 33
    DIVENT          shift and go to state 34

    multiplying_operator           shift and go to state 30

state 36

    (15) factor -> INT .

    TIMES           reduce using rule 15 (factor -> INT .)
    EXP             reduce using rule 15 (factor -> INT .)
    DIVIDE          reduce using rule 15 (factor -> INT .)
    DIVENT          reduce using rule 15 (factor -> INT .)
    SEMICOLON       reduce using rule 15 (factor -> INT .)
    PLUS            reduce using rule 15 (factor -> INT .)
    MINUS           reduce using rule 15 (factor -> INT .)
    RPARENT         reduce using rule 15 (factor -> INT .)


state 37

    (16) factor -> ID .

    TIMES           reduce using rule 16 (factor -> ID .)
    EXP             reduce using rule 16 (factor -> ID .)
    DIVIDE          reduce using rule 16 (factor -> ID .)
    DIVENT          reduce using rule 16 (factor -> ID .)
    SEMICOLON       reduce using rule 16 (factor -> ID .)
    PLUS            reduce using rule 16 (factor -> ID .)
    MINUS           reduce using rule 16 (factor -> ID .)
    RPARENT         reduce using rule 16 (factor -> ID .)


state 38

    (17) factor -> LPARENT arithmetic . RPARENT
    (12) arithmetic -> arithmetic . adding_operator term
    (18) adding_operator -> . PLUS
    (19) adding_operator -> . MINUS

    RPARENT         shift and go to state 45
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23

    adding_operator                shift and go to state 29

state 39

    (5) assignment -> ID COMMA ID ASSIGN . value COMMA value SEMICOLON block
    (24) value -> . FALSE
    (25) value -> . TRUE
    (26) value -> . ID
    (27) value -> . INT

    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    ID              shift and go to state 46
    INT             shift and go to state 48

    value                          shift and go to state 47

state 40

    (9) type -> TYPE LPARENT ID RPARENT . SEMICOLON block

    SEMICOLON       shift and go to state 49


state 41

    (3) assignment -> ID ASSIGN value SEMICOLON block .

    TYPE            reduce using rule 3 (assignment -> ID ASSIGN value SEMICOLON block .)
    $end            reduce using rule 3 (assignment -> ID ASSIGN value SEMICOLON block .)


state 42

    (4) assignment -> ID ASSIGN arithmetic SEMICOLON block .

    TYPE            reduce using rule 4 (assignment -> ID ASSIGN arithmetic SEMICOLON block .)
    $end            reduce using rule 4 (assignment -> ID ASSIGN arithmetic SEMICOLON block .)


state 43

    (12) arithmetic -> arithmetic adding_operator term .
    (14) term -> term . multiplying_operator factor
    (20) multiplying_operator -> . TIMES
    (21) multiplying_operator -> . EXP
    (22) multiplying_operator -> . DIVIDE
    (23) multiplying_operator -> . DIVENT

    SEMICOLON       reduce using rule 12 (arithmetic -> arithmetic adding_operator term .)
    PLUS            reduce using rule 12 (arithmetic -> arithmetic adding_operator term .)
    MINUS           reduce using rule 12 (arithmetic -> arithmetic adding_operator term .)
    RPARENT         reduce using rule 12 (arithmetic -> arithmetic adding_operator term .)
    TIMES           shift and go to state 31
    EXP             shift and go to state 32
    DIVIDE          shift and go to state 33
    DIVENT          shift and go to state 34

    multiplying_operator           shift and go to state 30

state 44

    (14) term -> term multiplying_operator factor .

    TIMES           reduce using rule 14 (term -> term multiplying_operator factor .)
    EXP             reduce using rule 14 (term -> term multiplying_operator factor .)
    DIVIDE          reduce using rule 14 (term -> term multiplying_operator factor .)
    DIVENT          reduce using rule 14 (term -> term multiplying_operator factor .)
    SEMICOLON       reduce using rule 14 (term -> term multiplying_operator factor .)
    PLUS            reduce using rule 14 (term -> term multiplying_operator factor .)
    MINUS           reduce using rule 14 (term -> term multiplying_operator factor .)
    RPARENT         reduce using rule 14 (term -> term multiplying_operator factor .)


state 45

    (17) factor -> LPARENT arithmetic RPARENT .

    TIMES           reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    EXP             reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    DIVIDE          reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    DIVENT          reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    SEMICOLON       reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    PLUS            reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    MINUS           reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)
    RPARENT         reduce using rule 17 (factor -> LPARENT arithmetic RPARENT .)


state 46

    (26) value -> ID .

    COMMA           reduce using rule 26 (value -> ID .)
    SEMICOLON       reduce using rule 26 (value -> ID .)


state 47

    (5) assignment -> ID COMMA ID ASSIGN value . COMMA value SEMICOLON block

    COMMA           shift and go to state 50


state 48

    (27) value -> INT .

    COMMA           reduce using rule 27 (value -> INT .)
    SEMICOLON       reduce using rule 27 (value -> INT .)


state 49

    (9) type -> TYPE LPARENT ID RPARENT SEMICOLON . block
    (2) block -> . assignment function
    (3) assignment -> . ID ASSIGN value SEMICOLON block
    (4) assignment -> . ID ASSIGN arithmetic SEMICOLON block
    (5) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (6) assignment -> . empty
    (34) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 34 (empty -> .)
    TYPE            reduce using rule 34 (empty -> .)

    block                          shift and go to state 51
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 50

    (5) assignment -> ID COMMA ID ASSIGN value COMMA . value SEMICOLON block
    (24) value -> . FALSE
    (25) value -> . TRUE
    (26) value -> . ID
    (27) value -> . INT

    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    ID              shift and go to state 46
    INT             shift and go to state 48

    value                          shift and go to state 52

state 51

    (9) type -> TYPE LPARENT ID RPARENT SEMICOLON block .

    $end            reduce using rule 9 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)
    TYPE            reduce using rule 9 (type -> TYPE LPARENT ID RPARENT SEMICOLON block .)


state 52

    (5) assignment -> ID COMMA ID ASSIGN value COMMA value . SEMICOLON block

    SEMICOLON       shift and go to state 53


state 53

    (5) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON . block
    (2) block -> . assignment function
    (3) assignment -> . ID ASSIGN value SEMICOLON block
    (4) assignment -> . ID ASSIGN arithmetic SEMICOLON block
    (5) assignment -> . ID COMMA ID ASSIGN value COMMA value SEMICOLON block
    (6) assignment -> . empty
    (34) empty -> .

    ID              shift and go to state 4
    $end            reduce using rule 34 (empty -> .)
    TYPE            reduce using rule 34 (empty -> .)

    block                          shift and go to state 54
    assignment                     shift and go to state 3
    empty                          shift and go to state 5

state 54

    (5) assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .

    TYPE            reduce using rule 5 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)
    $end            reduce using rule 5 (assignment -> ID COMMA ID ASSIGN value COMMA value SEMICOLON block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (factor -> ID)
WARNING: rejected rule (value -> ID) in state 13
WARNING: reduce/reduce conflict in state 18 resolved using rule (factor -> INT)
WARNING: rejected rule (value -> INT) in state 18
